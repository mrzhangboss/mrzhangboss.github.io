<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小伦子的笔记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mrzhangboss.github.io/"/>
  <updated>2022-10-10T15:04:14.784Z</updated>
  <id>https://mrzhangboss.github.io/</id>
  
  <author>
    <name>张伦</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>begin</title>
    <link href="https://mrzhangboss.github.io/2022/08/17/learn2love/begin/"/>
    <id>https://mrzhangboss.github.io/2022/08/17/learn2love/begin/</id>
    <published>2022-08-17T01:24:02.000Z</published>
    <updated>2022-10-10T15:04:14.784Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="258c2d4927ad46acebcb6355063bc821d622661f0f6a6918baff6b2b95147b8b">2f6b80f3f3099db5b271f54bf324e74d9f82cdb16bdc7b7837950284a03f7d83dd0633e60d3376f6a3cb8587719032914717ff32a39be7b1e02a654cbd066cc6844f303da67e513ae84be1fdc2493d96f551249ca026c7032bf359747c9dc1d5cc68e97ed2987208bf074feb80b3f3c24bd9b3ba2476f6e9606e359386951f18c450c689712e63d6d8d2c00b455a38fc0ecf1f0dc745cd61d0c1eeee217ab7929fa3d57406df088382557df28c4a4aea2f9c39361adbf66701bef87c17658b502ce7f312a19a30524c2230678477648718c6ce250cfc3524f97807281eabcd9678bd0109feaa185c24e03a8de8c6431ca91cf65b4656d069dc636e8c47cb55f153eb1159536a9e5ce893376e53e90303331ef42d7bb57bbe0efbbfb2a5005b7506aff89657d68cfad0f20402e722018c868f5448def439e70edbd172421ac5ce0027ce4160d71e16b40299378517176361667c7b51ae60e2e3781f858723ec6b6afe9b40ea90cfeeaf99ce7e20e7075605bac894d7e24eb77305b9cb61d9286ecd782da4dc146cdab3d6de4b555b2adc64e4ccca14ab251664fa17f1b75fab69d51560358d7e6066c3d6423ded538780c20c8ed5646b9cf58cbaa94a11b7a255f6321bf4964f0128b71d6d740e7bc4ebb8b94d6e907dd091e19584bcddbdda36eb42d9c92acc9ef3bc68e5a36d3a7c703662b4e87ffa59bb2d8441a57275ea6d9330c7f6c8b5e1743aefea16ec279c6cca709ee6d7695df1d409ca22ce61e93e557fa84086d6b1367910d21a69e6081068a56e4d3c09928fc06b59384a1e55f8e1792f1a5b243d1d1c625c79e82193c614ef0b42fd4b1544cac25268a81e63ff3127c0e4b6c51ba06bcf9513def0696665b2ed8f2f32ab93090725135566f81b8e1b468b4f6b6fb90c99321aee35ef22e07f5dc3cce84287b208d4861020e675cffffd00a124187b549bdf5a8d5a457958b7ee3d8005a318995cfe512808d29545832c84235bc2f37b344d69e5cf226f7030225101c3075f7838626b016ba843728712a63cb6e9dc66662c9ed50d06c71b13ba6b0a199ae89ffa4e6821db74f92b3b6b36708b27fec70f528025fac5daf9eb2e576006ab9e54081b27771fa136c91cf532977112b4cb50df21cb89d453ad6e0dc38cd824fc7f400473b31e09c0b368be120b9b929d370fd71a1ad019b06282737c9875859910410e273477fe6e8ad3636183603b78ea640bbe5000916f28d06eca3678075ae8b21a1a2cd6f2558cd0d7f47ce32882bd6f74f12c10e65a96a4134b202a3a40d6aed151293fda2b6035fc72376167e5e0682d7452f7d84b2639c37d4adf21905127d6cca64194ea2a7f8c414702d59541ee36245853f355b5a83a0b313ada47b630a0f3ee2c08f7669a3d7f4afc6d390f39f1a19e9c72d600a85c483da5580ec06d0426506486a11f04b6a60c481ce3aea719180642a249295054b55a3ac5d36b2f6eafec1b9b7eadc85ad74b856fa20390c2d6457952b6e1e8754b1208e0ddece03e29a77a354331506d3b0d9289ff9f429a49d521850379d6670ab55427223c2e659804ddc429b53bacf357f6163d497ced20a3b401005fe3e2f4f68179e714e1e82b9b4c332f190c4a6699d2cc32b0f81ed489e97ffc0cb24b2d34df42b6663c15b55eb212532a903c1b4cc3251a96be99add12783f1abeeb641e0d917eef6dabec45bfc33b2311055d1ad10c1aa26fcfe2e0364409d42245e77e4abba67b4afbda15b5fa59cb4bb35e5e6f539fb54fc4b09f68a6cb2e21a024e20ed3cdeab7fe87931b1e4d497ce0a0a39a86875bdf9d39d37c964bf0da8bc34a0e15559a8b885c72057c281908a6bcf9eca7754119b16c073f2f886507c6fcda19e3b19af61b2caaeb04720358a1b42c186f564d5534e572d722f09ade25bde10af913a950b4cddcf969bf858337e19f6d6f9cf4ce8d9909aedb4e0208f0c95274e1de858f502cbed27a2095d9f0b877596b9b97fa88094adfd9681e5c3265a04e4c6239b225489907442151c6b5a92c3eae199947245d9abf5942886bdc64f42f5addcbae3f51c7e7b5ab544f7a053a4be9fafc914437e4f7e70b9</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      有东西被加密了, 请输入密码查看
    
    </summary>
    
      <category term="感情" scheme="https://mrzhangboss.github.io/categories/%E6%84%9F%E6%83%85/"/>
    
    
      <category term="感情" scheme="https://mrzhangboss.github.io/tags/%E6%84%9F%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>Sun Jul 24 2022 00:00:00 GMT+0800 (China Standard Time)</title>
    <link href="https://mrzhangboss.github.io/2022/07/24/learn2love/2022-07-24/"/>
    <id>https://mrzhangboss.github.io/2022/07/24/learn2love/2022-07-24/</id>
    <published>2022-07-24T11:36:37.000Z</published>
    <updated>2022-10-19T13:29:49.935Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="0d23a0c1cecba96529672eeb473822be7a6a928626c0e28dd8c6c5aa8563bccc">2f6b80f3f3099db5b271f54bf324e74dbb6e437b8573b2a17469c894a97c488c0a3e07d83f40580d8d87c50c4712db6aa99b982d8755d91d2ceddd45cb71f28b4d692be7fa975f9f607f35d9639663dbfb36733740ba6576ac37be1a92d63022ce6138745015e0531119293a567d4537860df7f8b1d73b26387021ce46e6ad669c6397536d6411d13c1edbe39adbca0c25ebfd34b9fe1b160ebe6986797ff030348877f66a55359180ff5395518f440857c28f18eb1560387e95d215a7576e6f632f7341a1176b727696e0e94d9bedd1f1fea2096601a48c7bb7394bc9220544eb7c9c3114064e41de26c435d2cde7fd6a4f3ee201b14d7cf7b5d31f4c0aba6d15513e2c4bca7a7278139bb16abb530f6d8bbaf6ae4f5a062923987004468adbba591f6f6415a1192ce49cf845b6d6abcc0555bc7ea4dd4bba866719863758463db4ea53a1bca5ba52a5a371e59234f1aeb37c1e29855a381759851013b1361c9b79eaf0966501f4d9b240fe8c02f8964c1c2ba2ef7189e345cb75c4bf20ff8e53e19e6f97c5837791bf769c76cc2d16249993604cc3c481e75d6ccde07f4cb9b12ece6293769e933e196c9694fbb7cc9248a24efc60b998377e66d921e67a01acf16b1e49a3b0297fcea80c1cd20ad5ecabafc58a70075543e7295a487337a8cb43200b7378da3d1b1924199a494fac2296d1215273c94f3da80ab329bbc7cb098765239fecb60f3fda32f1d88b7707575caec656ec6bda6ff6dd64671057fa15f4de31cfb692e759c3c08524f3170ecfaeb45a0bf8839b1cd5162b5303c627b1d2f26d0f848a4a0558599ca6c513d6621159814646b39f36a43e4f97a1bfda5b3e4761e6acf4fd4b28cfdcb8cea4afb74d408549a5f822a9e30b373a5081e4878e83e49362be01c34315d1257f7ec2338913b4287f628f45236de3b98c267d57a62222473500b266e13b0e7bb80ac00ea1cef47943090d8703073c5134b9e417fa91fc41cc1e71666b8d4eae1e046dda85a0d51f0f57e797b50f746dffa7e622dde42a2a53cf28626d700ee92483c451bd288df8668d3505c520951a258775b2e2e8bc3b73a32be481fe5e956ea6235446a1595ee3d879f4d69c2fda4450fe397dc3f0b980ed0e9a30ffe35c36557d90664ace05b63e3a0de80c80ad87ddd38e2d43030a211617e9330034292dccb4a8c9b23c989a4c2a11b8fc71e0a792c58823de12b0cf54506de4809558d408b45dbe5ad0fb22378bf94265296a6f1e0945877dadea58ac3ae768cbe8238a9daf0eaea21989a574847e1792fb5de6d6fb3beae1b0953f5d5531be2a58054c527752b44ddde64b57f9d0bc2523cfeac5b358ac9c3dd12b75ad45c6a3ca85036ec8e470469cd6d2736fdd2e0704f25e28894d624156aa34f16ff8ddfb44b538a0cb361f2f5fe560b5ed21ae7963bbcc6e3dc17c65b54f53e2298fd423e51d8208701c683deab4939182b13a4cf99b228fb1e2c869d3271d4d1f0ad609ffe69047ebdc58672d45f2d8a9e7b37da8b153b87ab19cecf9ec94ccb96dae62599d600d15e8ecfb794e2d48641a09724a851764d3335d3fcfc843c0d81c991fe06d7650b5741721ca2d955cbd82edd1a30aa6f368dd57fdd2bd7e253677260530da29425d47cbc72c89c459982f197c5351a940d667d971e3dcd55b749f505cfb03fb2ecc1ff52a0bf5e0e46c034836d904e8d26d653fa05b74dc63c2c515ae494e66168b73256fc7f6ecf779a991629e339262d6f529e8291288e99ea810739e5b4eae8e68592b93d1c34cda5175117de4b9b8d4bdec4505ed4ece8e700ef675e26aa85fcae480dee53fd9e2b13cf37a1c3f4093672b281d13e2d32023736095324de46376550ca18694fd6c198d8e8f12609441877651fbd60e02631e27b6882a56366d0b9f5cec34eb850f8b634e9ee87ebf24c4d359b7a50ffad774c49d675043fe78d8aabe511e4d7f05a47c4556bc0d57222e96f9163e763139f9a6f224d1d2ccf38d241043615ece48e91728390485c3dec0973d0d90a684bb29bed7e561d25beef0c425ad4302baab91b05772d9a3b113074f2c48933e95e1f0e8c424b5f8de5b4c0f1fafa25270e5402a76b81a34343d6a4b961896b9e296aa1bbca401aa0e5e05506c2b982f3c0f10593de27057f01e14c7ca90d8cd1019c93145e5e0324f259ad48a13bf5024f016af48bf2b481ba181523b429f5f26dba03570b573e10237e51760f62be3cbbd71527b2c7151478114cad6a6cb1a11eed499c12034f03974a2ed82dc16e0dd237b5aacd03cedff4c8fecc96820999c208f4bb38652586877dd56867f1adfafe0cf23b8d24e55aeccfb9709bb752570cb39315cfc75a4be61a2abf43845773757ede983b8c935ccc71cb4e0a7e1ec512db050eb9b34b13fc073fbb9f88ce6d4f7fc04a8b26ec422432829ac851e82ca9797e5f3bbfa3ce911674224711e73c614ba37788d16f567f932dd61d45c7a22b0fd7a48f8c029e0da519bcd62f2910088614619b061af4464828493faa165db0bf140a2b3d289299a027ca175bc930287619469cc234c03f0b59cd8065e8327e5c052aa650660f70ed480f9d4f39728359eafa8fe33a81a240f1a87b6cae1a9e0d7da2e73c60f8243dbc71a13ebced9325d8509aa6c7ed9d2f028a1c03a2b1cbe989461a740ecf85f6f686fc201fcc72a1d69690087e4409978f0c4d10e9a1b4f487cf82300be395054ed66f5eac91af86d09b41f5a403707eef4d7986c56a87cccd1c62417ec0dbcc0dd645557c78b945a39d3b924cd89005412dffd2be46df9f8791c8c12df1055de9fdacccd2c3ca72550315593eb1e5cb6729b19a76ed9ec6ddb1e03077752dd44625252c17e411c0f45526952c718efdc8ebf697f3f5e35adfb0e01d5cb0f5674eb4f8e8afb4782d3e668030951d14280456be4d9b898d5ba98f803c1b8365128a9d1d693a54a81e9ab32f347ad39edeac028b9541a4798ab2bab78694aa1a12837201f32e3e1188636c2f85024ddf7a210db1b78d1664b9b430c073c8d9be0f62189e067afd47bedcee70d4aeb80c00d1cf1f50b2809a88b3dc3b07610b21ff39fcbeb1862a1eff91c1714c17ddeed6282a004110d73701865eca95e8e5764af079ac5909938b45be802f1cfb34494c1165c6f3df6c098454d5d424304b216dae9367a4f73fdea83771ff59adee878b81a0619f6cd1e5025f809129085a1149135719c00390ae98c329a8959878fd3491bc102817ee67ea4d937ca97aedd24c293d9feaf1025c9b1a0bd2498662faf37fb8b8fa4543268baf6b1c0bee1cd74567fcb8f9d113a41dd800dcceb4c2efd7add84d6797c22dd32673822e6b7a6fea6390c496344e311487280569c9fe592099be8d630db8be3337baa2c4828fe06d7143ad7c9c1e72f913b0cdf0cacb50806aad8bb83994e438413e9fad7c171956310a7071911070d79270254447e5756627be7b082cb2293731ef983b4976cdabc18cf82e4fad6b544831bc89dddb23b83cb765ecfb4e5d7681006f6b5a08020c009ed05900e11dbb261acfc597e1073147bfe4d4c5383e47a87aaec33eb1c7c0e0fd5b9f7872546590909dcdda3783181eaf939a75de7eab0991af23d24f1b5cd39c45ec79ab66bb851b126273e2a7acff75e38c9fb03cac9f1daa1e62126f29f1d68bd8e04472b5e7d30529ce139f9734052ce12b081d7ab67ba1a244f28ec341b62a7ff646a3d661d784235a9d804c23fa8bb36e89a059d34b896efa736843017bd311faab52ec54068c1468e5f890d3d2ee517a525dbd1512551df2e2a3a5de32824ceaaf4cfe503cd775342d0acb8a739510ef0315c40913fb704d7e3ebf26f107b8cfdc50dd89f2d6bfc10f7c181e5ded6c8be6b533bbbc7aacf977f8433034e7cb0b8c3e4c559ac70d88c2374e0c4fc074ddcd9f9f4c786b17aeeae203dd44a25ef8a745fc38f6f07d74033e43348fc198822e2b5ef820fa7a023a803fd242cb7ebeb15809a692d89293e07ac1a1fd786dfe51cc4020869f478b67deda05850533ecc077a788a6a491247b3df771bbd515490fc33de8be9598b295b09e9a417f92f58f5fb15c73fb8232140cfcac54b8d0fb1cb14e0f41e9c0e50931bfa71b93b6010c1874510a9f153ba907b8c0be73e426eb2f626a8b57e429d45941876ed08a559918a1957da7b717ac7d1a2484b57eab56d8d1e36c5606aa2c30d489df056055f93b56c55536fa00482ff98eda82475c73bbe594549efba98cde170fc28d5d8381bfb15a1a8467ccabcd79714de26350b0e88f753b3d8c7bf7d35846c4aee46fec4640cb09559bce0057da32a837713a6d73133507845d134d54f67c1de5a3bea9638a8c50e28be92b09b1c9fc3abe163eed055fafbe81b31b0c5842f9835d57dcf61e2a6159f0c080b84ff50d9b35b1f3ad56a3245924fef4494026e0b40613ba705865234f69f5000f4033bdb7a3a38ffe901efd243d183727611069da38159fe4f892e9f0fb91a80044611bf0f7cf6b3719bae7881ceebb1b2059c46cfbbc89484a071709ec0edce2afb06081f60f1df924372d2eb2666fc0bc2b216c9f7c45bb413932b1dea9f7a2f13c3ee22dbd51f34a8b37d082382156391066ffb0f472c8e9fa62cd8d7e6b06479cf4faaa32f2b53ee76f6bfd3f2b4651316bd687cc2596fadc7bbd710c4a84f4e062f64e3ea68c62e38e965df2bc8fb0eedaf3a20c47c08a3a2e938fa0763bf</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      有东西被加密了, 请输入密码查看
    
    </summary>
    
      <category term="感情" scheme="https://mrzhangboss.github.io/categories/%E6%84%9F%E6%83%85/"/>
    
    
      <category term="感情" scheme="https://mrzhangboss.github.io/tags/%E6%84%9F%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>秒杀系统的思考</title>
    <link href="https://mrzhangboss.github.io/2022/07/02/java/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/"/>
    <id>https://mrzhangboss.github.io/2022/07/02/java/秒杀系统/</id>
    <published>2022-07-02T15:22:46.000Z</published>
    <updated>2022-07-03T10:01:17.381Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近的业务也做了一个类似秒杀业务的，自己在做的过程中也感悟到没有完美的解决方案，每种方法都有自己的缺点，<br>要基于业务去设计核心，而不是为了秒杀而秒杀</p></blockquote><h2 id="什么是秒杀系统"><a href="#什么是秒杀系统" class="headerlink" title="什么是秒杀系统"></a>什么是秒杀系统</h2><p>秒杀系统就是：<code>抢</code></p><p>用生活的例子就是，一群人去超市排队买瓜，一人只能买一个，一共100个，抢完了就没有了</p><h2 id="秒杀系统核心"><a href="#秒杀系统核心" class="headerlink" title="秒杀系统核心"></a>秒杀系统核心</h2><p>秒杀系统最核心就是，如何确保数据一致性，不超买超卖，网上这种文章一搜一大把，你只要安安静静看几篇就能明白的七七八八了</p><p>在你看完之后大概就能设计出一个简单的<code>Redis</code> Lua脚本来进行秒杀，我这里就不介绍怎么写，教程实在是太多了</p><p>我这里想提出一点就是，大部分的教程都不会告诉你，<code>Redis</code>其实很脆弱的，它可能会崩溃，虽然概念很低，但是一旦崩溃，你的数据就不准确了</p><p>假如你完全依赖Redis作为秒杀成功标注的话，在极端case下面会出现超买超卖现象</p><p>怎么解决这个呢，其实很简单，只依赖Redis作为秒杀的过滤器，通过Redis完成秒杀，不一定抢购成功，要等数据库确认之后才能算秒杀成功</p><p>那么我们Redis是不是完全没有用了呢，恰恰相反，作用非常大，Redis将流量过滤到数据库可以接受的程度，假如流量全部打到数据库上面，数据库瞬间就崩溃了</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>在使用Redis过程中，我发现一个好玩的事情就是使用Redis做一个消息队列，并且对消息进行压缩，<br>这个压缩是指在消费的过程中，使用Lua脚本，批量获取队列值，然后清空队列，达到一个消息压缩的情况</p><p>相当于在Redis层做了一个数据处理的工作，优化了数据传输，但是有可能会造成Redis性能下降</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>秒杀系统说难不难，说容易不容易，新手很容易忽视在高流量下面各个系统崩溃的极端情况，然而这些情况都是必须要重视的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近的业务也做了一个类似秒杀业务的，自己在做的过程中也感悟到没有完美的解决方案，每种方法都有自己的缺点，&lt;br&gt;要基于业务去设计核心，而不是为了秒杀而秒杀&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是秒杀系统&quot;&gt;&lt;a href=&quot;#什
      
    
    </summary>
    
      <category term="Java" scheme="https://mrzhangboss.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>《我编程，我快乐：程序员职业规划之道读后感</title>
    <link href="https://mrzhangboss.github.io/2022/07/02/summary/%E6%AF%95%E4%B8%9A%E5%9B%9B%E5%B9%B4%E6%9D%82%E6%83%B3/"/>
    <id>https://mrzhangboss.github.io/2022/07/02/summary/毕业四年杂想/</id>
    <published>2022-07-02T13:35:48.000Z</published>
    <updated>2022-07-02T15:22:54.699Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一眨眼，四年过去了，再过几年就到了三十而立的年龄了，年轻的时候走马观花，<br>好像一直为了学习而学习，为了规划而规划，在经过被社会的毒打之后，<br>自己眼睛里面好像也没有当年的光了</p></blockquote><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>突然发觉自己该给自己重新规划一下未来了，之前定的规划好像变成了墓碑，矗立在哪，纹丝不动</p><p>在网上找到这本书，静下心来细细品读，颇有一番感悟</p><h2 id="感触"><a href="#感触" class="headerlink" title="感触"></a>感触</h2><ol><li>热爱编程，而不是为了工作</li></ol><p>假如编程只是一份养家糊口的工作，那么你会越来越抗拒他，当你下班，你只会去做让你开心的事。<br>而程序员进步最大的时候就是在他下班后。</p><p>不是说你下班之后继续忙工作的事情，而是脱离你的工作，专注于编程的进步，你当然也可以钻研你工作<br>上有疑惑的东西，去搞懂他，去优化它。</p><p>你可以把编程当做一个游戏， 花时间在它上面，打通关，升级自己。</p><p>对于我来说，我还算挺喜欢编程了，假如是个新技术，我会立马把它钻研到可以用的地步，<br>但是每当我想深入一个领域， 我最大的问题拖延症，<br>假如没有什么deadline，我一般就会能拖就拖，结果拖着拖着就忘了，所以其实对于我来说，<br>我需要把编程当做一个游戏，自己设定每个阶段的deadline，像升级打怪一样把某个知识点钻通</p><ol start="2"><li>向人请教如何成长</li></ol><p>不知道是不是编程开发总觉得问别人不去很羞耻，应该面向google或者百度编程，但是很多时候很多问题不是百度就能解决</p><p>我们需要抱着一个班级最差生的态度去向别人请教，不是问了懂而问，而是为了变的和他优秀去发问，他是如何做到</p><p>大部分人比如我都很乐意把自己所学教给别人，也会把自己觉得让自己成长有帮助的方法告诉别人，你要勇于问</p><p>变强的最快的方式不是像小说里面闭关修炼，而是找到一个良师，21世纪了，我们要站在巨人的肩膀上才能变得更强</p><ol start="3"><li>自己反思、适时放弃</li></ol><p>书中讲到一个抓猴陷阱，就是在地上挖一个曲折的洞，里面放满米，傻猴子会拼命往洞里掏米，当猴子手里抓满米<br>之后手就拿不出来了，即使你站在他旁边他也不会选择放手手里的米，这样就抓住了一只猴子</p><p>虽然我们比猴子聪明，但是当我们手里抓住的是我们看中的东西的时候，也不会舍得放手，所以给我的一个感受就是得学会分轻重</p><p>好比打游戏，千万不要上头，人家交闪了还越塔追，最后被人家丝血反杀，我们得放弃击杀别人的机会，即使只需要a一下就能收到人头</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次分享自己也学着书中的方法，提高自己的写作能力，当然书中说了一些其他不错的观点，但是我选择了三个对我感触最大的，<br>这些缺点在我身上也有，所以我感触也很深，也第一次应用上了哈哈，我给自己deadline是今晚写完，bingo！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一眨眼，四年过去了，再过几年就到了三十而立的年龄了，年轻的时候走马观花，&lt;br&gt;好像一直为了学习而学习，为了规划而规划，在经过被社会的毒打之后，&lt;br&gt;自己眼睛里面好像也没有当年的光了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;起因&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="随想" scheme="https://mrzhangboss.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>RPC大纲</title>
    <link href="https://mrzhangboss.github.io/2022/03/19/java/rpc/RPC%E5%A4%A7%E7%BA%B2/"/>
    <id>https://mrzhangboss.github.io/2022/03/19/java/rpc/RPC大纲/</id>
    <published>2022-03-19T07:54:05.000Z</published>
    <updated>2022-03-21T15:53:49.809Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近想系统学一下RPC框架，下面是我学习路径</p></blockquote><p>阅读<a href="https://github.com/Snailclimb/guide-rpc-framework" target="_blank" rel="noopener">一个简易的RPC框架源码</a></p><p>主要是学习了</p><ul><li>服务端注册中心注册服务</li><li>客户端创建动态代理，当调用方法查询对应服务所在地址，序列化请求体并发起远程调用</li><li>服务端使用netty，对客户端自定义协议进行拆包，并调用对应注册类方法</li></ul><p>com.alibaba.dubbo.rpc.proxy.InvokerInvocationHandler</p><p>com.alibaba.dubbo.rpc.protocol.dubbo.DubboInvoker</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近想系统学一下RPC框架，下面是我学习路径&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;阅读&lt;a href=&quot;https://github.com/Snailclimb/guide-rpc-framework&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
      <category term="Java" scheme="https://mrzhangboss.github.io/categories/Java/"/>
    
    
      <category term="RPC" scheme="https://mrzhangboss.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>王者荣耀感悟</title>
    <link href="https://mrzhangboss.github.io/2022/03/05/summary/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%E6%84%9F%E6%82%9F/"/>
    <id>https://mrzhangboss.github.io/2022/03/05/summary/王者荣耀感悟/</id>
    <published>2022-03-05T14:50:40.000Z</published>
    <updated>2022-03-05T15:34:45.545Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近玩王者玩着玩着突然有些感悟，感觉有时候通过玩一个游戏也可以看到自己身上的不足</p></blockquote><h2 id="追杀还是放弃"><a href="#追杀还是放弃" class="headerlink" title="追杀还是放弃"></a>追杀还是放弃</h2><p>有的时候会上头，追着残血追到二塔被他们围殴或者杀了人却被搭打死了，其实这个完全没必要，一个残血，其实你不打死它，除了那种后期吸血怪，基本上都是要回泉水补血，差不多就相当于杀了他一次</p><p>有这个追人的时候，你还不如继续扩大优势，推个塔，拿野区资源等等，王者是一个经济游戏，在你装备还没成型的时候，你90%的任务都是快速发育以及阻止对面发育，通过经济差碾压别人</p><p>其实我感觉在现实中我也是，有的时候学一个东西也容易上头，打破砂锅问到底，最后把自己的耐心磨完，忘记了自己真实的目的</p><h2 id="观察局势"><a href="#观察局势" class="headerlink" title="观察局势"></a>观察局势</h2><p>有的时候，无论是劣势局或者优势局容易梦游，经常“目光短浅”，为了几个小兵，孤军深入，最后送个人头快速回家，或者有的时候打射手，一直就是一抓就死，前期大优势打成逆风</p><p>观察局势说难不难，说简单也不简单，毕竟对面5个英雄，你又要对线，但是其实很简单，基本上关注中单和打野位置就好了，当然假如对面野辅联动也得关注辅助的位置，你只需要关注他们是否是会来抓你</p><p>所以其实高端局经常看到大佬说什么给个假动作，给一个往下路走的信号，其实往上路走了，虚虚实实，真正假假</p><p>其实要想养成这个意思，必须让自己脱离这个游戏，培养自己一种上帝视角，自己控制的这个角色输赢都无所谓，你会开始猜对面在干嘛，去预测对面的动向，所以以前英雄联盟有个主播叫大司马，大部门人特别敬佩就是他的预测能力</p><p>基本上他能知道对方在干什么，所以其实你和大神之间的差距就在这里，大神知道你要做什么，所以他能制裁你，你在他眼中和机器人没什么区别</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自己之前其实不怎么喜欢玩这种5V5实时对战的游戏，喜欢玩人机，因为5V5中有些人太在意输赢了，会因为别人的失误会去骂人，在这个团队游戏中，经常有射手骂打野，都被对面打野抓烂了，自己打野没来一次，大部分人只会在别人身上找原因，而从来不在自己身上找原因</p><p>自己一抓就死还不是因为没有注意对面打野动态，人生也是这样，大部分把自己不成功的原因归结于没有一个好爹，起点没有别人高，与其抱怨还不如想想怎么才能混起来，发育起来</p><p>其实感觉人生有的时候和游戏一样，那些成功的人他们只是比普通人看的更长远一点，普通人只看到眼前的芝麻，成功的人看到了远方的西瓜。</p><p>努力不一定会成功，但是不努力补每一个兵，打团的时候就打不出伤害，你最后就会输掉这场比赛，游戏和人生一样。或许你没法决定自己的队友，但是你可以成为那个在队友发起投降的时候不放弃的那个人，只有有一个不想投降的人在你们这边，你们就不会自爆水晶。人生也是，你不放弃，没谁可以让你放弃。</p><p>选择权在你手里。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近玩王者玩着玩着突然有些感悟，感觉有时候通过玩一个游戏也可以看到自己身上的不足&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;追杀还是放弃&quot;&gt;&lt;a href=&quot;#追杀还是放弃&quot; class=&quot;headerlink&quot; title=&quot;追杀还是放
      
    
    </summary>
    
      <category term="随想" scheme="https://mrzhangboss.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>IO总结</title>
    <link href="https://mrzhangboss.github.io/2022/02/19/java/IO%E6%80%BB%E7%BB%93/"/>
    <id>https://mrzhangboss.github.io/2022/02/19/java/IO总结/</id>
    <published>2022-02-19T03:21:52.000Z</published>
    <updated>2022-02-28T13:34:52.900Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近被NIO这个概念弄得有点晕，一会是Linux的NIO一会是Java 的NewIO也叫NIO，然后Linux又有一个AIO的概念，但是Java里面好像没有，所以就好好理理IO到底是个啥东西</p></blockquote><h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><p>我们都知道IO就是<code>Input Output</code>，但是IO模型其实是给读取也就是Input来做的模型，因为Output非常简单就是往网卡写数据，但是读数据就有点不一样了</p><p>为了高效的从socket里面读数据，Linux给IO创建了5种模型</p><p>第一种最简单，就是同步模型，执行一个系统调用，然后等内核从网卡读取完，最后讲数据从内核复制到用户空间就完成了一次IO读取，这种方式对内核来说最简单了，但是对于用户来说就很低效了</p><p>一个线程基本上都卡在IO上面了，即使有多线程技术，但是万一用户量很大，线程是有限的，而且有的时候万一用户网络很卡数据包很大，网卡读数据就花了几个小时，几个小时都耗在一个链接上了</p><p>所以提出来第二种IO，同步非阻塞 IO，也就是NIO，这个IO和上面区别在于，执行系统调用之后里面就返回了，不会等待内核堵塞用户了，但是假如内核没准备好，则会返回为空，但是这个也有个缺点就是<br>假如一直没准备好，你就得用个队列把这些没准备好的存贮起来进行轮询，假如队列里面多了，你会耗很多时间在无效轮询上面</p><p>所以在NIO的基础上，操作系统提出一个多路复用的概念，其实就是相当于操作系统给你维护了一套消息队列，当有IO准备好了，就返回给客户端，所以其实对于客户端来说，现在的IO还是一个堵塞的，<br>只有当IO准备好了才会返回，操作系统在维护这个队列上面也做了很多升级，从最初的<code>select</code>到<code>poll</code>到最后的<code>epoll</code>，操作系统一直在优化，以达到一个完全消息驱动，节省不必要的CPU浪费</p><p>当然前面的NIO的需要轮询的缺点可以通过信号来解决，所以又引出了第三个模型，就是信号模型，不幸的信号模型在大量IO的情况下会丢数据，导致不可靠，所以这个模型其实用的也少</p><h1 id="Java-New-IO"><a href="#Java-New-IO" class="headerlink" title="Java New IO"></a>Java New IO</h1><h1 id="异步到底是什么"><a href="#异步到底是什么" class="headerlink" title="异步到底是什么"></a>异步到底是什么</h1><h1 id="异步优缺点"><a href="#异步优缺点" class="headerlink" title="异步优缺点"></a>异步优缺点</h1><h1 id="异步的替代方案"><a href="#异步的替代方案" class="headerlink" title="异步的替代方案"></a>异步的替代方案</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://www.linuxidc.com/Linux/2017-09/146682.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2017-09/146682.htm</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近被NIO这个概念弄得有点晕，一会是Linux的NIO一会是Java 的NewIO也叫NIO，然后Linux又有一个AIO的概念，但是Java里面好像没有，所以就好好理理IO到底是个啥东西&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;IO
      
    
    </summary>
    
      <category term="Java" scheme="https://mrzhangboss.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Bean复制真的那么慢吗</title>
    <link href="https://mrzhangboss.github.io/2022/01/17/java/Bean%E5%A4%8D%E5%88%B6%E7%9C%9F%E7%9A%84%E9%82%A3%E4%B9%88%E6%85%A2%E5%90%97/"/>
    <id>https://mrzhangboss.github.io/2022/01/17/java/Bean复制真的那么慢吗/</id>
    <published>2022-01-17T13:16:12.000Z</published>
    <updated>2022-01-17T13:18:01.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>最近在业务代码中经常用到的BeanUtils.copyProperties，有的时候在想，这个东西在Java里面真方便，但是性能怎么样呢，然后找了一篇博文<br><a href="https://www.cnblogs.com/kancy/p/12089126.html" target="_blank" rel="noopener">https://www.cnblogs.com/kancy/p/12089126.html</a></p><p>大吃一斤，竟然要100多ms，我们接口压测性能也就40ms左右，调用这么个方法竟然耗时要这么多，本着不传谣不信谣的精神，开始下面的测试</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>首先我用Python生成两个大类A，B，两个字段数都为254（因为Java最大属性就是255），然后生成一个类C，其中有个静态方法，能将A的值全部都赋给B</p><p>最后我跑了一下结果</p><p>下面是结果</p><pre><code>bean复制热身🚀      1100次耗时:      264.00000毫秒 速度：       0.24000毫秒每次正式🚀   1000000次耗时:    14383.00000毫秒 速度：      14.38300微秒每次硬复制热身🚀      1100次耗时:       12.00000毫秒 速度：       0.01091毫秒每次正式🚀   1000000次耗时:      116.00000毫秒 速度：       0.11600微秒每次</code></pre><p>因为JVM有热加载技术，所以我运行前都让它热个身，结果很哇塞，的确BeanUtils的速度要比硬copy要慢100倍左右，但是其实对于程序来说，14微妙也是非常快了，其实除非你在一次请求里面要用这个方法上百次，其实问题都不大</p><h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><p>但是我又有个疑惑了，为啥bean复制最开始的1100次要耗时那么那么长，到底发生了什么，接下来我把热身的时候，蜂刺数据提取出来（上一次执行耗时和这次执行差距1ms），结果如下</p><pre><code>0 cost: 101 cost: 015 cost: 9516 cost: 217 cost: 0127 cost: 2128 cost: 0</code></pre><p>我执行了很多次，在第0次的时候，和第14、15、16这些的时候都会耗时巨长，第一次可能是因为建立反射缓存，但是第14、15、16为啥会耗时那么长呢</p><p>接下来我们深入源代码看看，为啥会这样</p><h2 id="源码探索"><a href="#源码探索" class="headerlink" title="源码探索"></a>源码探索</h2><p>源码在 <code>org.springframework.beans.BeanUtils.copyProperties</code> 中</p><pre><code>private static void copyProperties(Object source, Object target, @Nullable Class&lt;?&gt; editable, @Nullable String... ignoreProperties) throws BeansException {    Assert.notNull(source, &quot;Source must not be null&quot;);    Assert.notNull(target, &quot;Target must not be null&quot;);    Class&lt;?&gt; actualEditable = target.getClass();if (editable != null) {if (!editable.isInstance(target)) {throw new IllegalArgumentException(&quot;Target class [&quot; + target.getClass().getName() + &quot;] not assignable to Editable class [&quot; + editable.getName() + &quot;]&quot;);}actualEditable = editable;}PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable);List&lt;String&gt; ignoreList = ignoreProperties != null ? Arrays.asList(ignoreProperties) : null;PropertyDescriptor[] var7 = targetPds;int var8 = targetPds.length;for(int var9 = 0; var9 &lt; var8; ++var9) {PropertyDescriptor targetPd = var7[var9];Method writeMethod = targetPd.getWriteMethod();if (writeMethod != null &amp;&amp; (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName());if (sourcePd != null) {Method readMethod = sourcePd.getReadMethod();if (readMethod != null &amp;&amp; ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {try {if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {readMethod.setAccessible(true);}Object value = readMethod.invoke(source);if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {writeMethod.setAccessible(true);}writeMethod.invoke(target, value);} catch (Throwable var15) {throw new FatalBeanException(&quot;Could not copy property &apos;&quot; + targetPd.getName() + &quot;&apos; from source to target&quot;, var15);}}}}}}</code></pre><p>借助arthas我们可以知道第一次加载慢是因为耗时都在 <code>getPropertyDescriptors</code> 上面，第一次的时候需要通过反射去获取，这个时间在我电脑上要5-10ms左右，之后再次运行相同的类就不需要这么长，但是为什么在15-16次会有一次比第一次还要长的耗时呢，araths的结果我们就不粘贴了，其中其实耗时都不长，耗时99%的时候都在<code>java.lang.reflect.Method:invoke</code> 这个方法上</p><p>我们知道反射慢是正常的，为啥到了15次之后就没有速度慢的呢，原因是JVM会对发射做一个优化，当请求同一个反射超过15次之后，就会编译成字节码，所以之后速度就起飞，但是由于第一次要生成字节码，所以它耗时还要比第一次通过反射获取的还要慢</p><p>具体资料为：<a href="https://blog.csdn.net/zhang6622056/article/details/98950855" target="_blank" rel="noopener">https://blog.csdn.net/zhang6622056/article/details/98950855</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这个实验，我们知道，原来即使使用反射，其实JVM的速度也能优化到几微秒，假如你的类不超过50个字段，其实硬编码和Bean复制其实差别不大，你追求的极致优化其实都是优化几微秒，相比于网络的ms优化简直不值一提，而且目前其实也有很多优秀的框架，如<code>JMapper</code>,<code>MapStruct</code> 等可以生成字节码，而不需要你硬编码</p><p><a href="https://segmentfault.com/a/1190000040791635" target="_blank" rel="noopener">https://segmentfault.com/a/1190000040791635</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;最近在业务代码中经常用到的BeanUtils.copyProperties，有的时候在想，这个东西在Java里面真方便，但是性能怎么样呢，然
      
    
    </summary>
    
      <category term="Java" scheme="https://mrzhangboss.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>2021年终总结</title>
    <link href="https://mrzhangboss.github.io/2022/01/17/summary/2021summary/"/>
    <id>https://mrzhangboss.github.io/2022/01/17/summary/2021summary/</id>
    <published>2022-01-17T13:14:23.000Z</published>
    <updated>2022-01-17T13:15:30.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>2021年，对于世界来说都是一个魔幻的元年，新冠在全世界肆虐，然而每个中国人都被保护的很好</p></blockquote><p>这一年对于我来说也是挺魔幻的</p><h2 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h2><p>记个流水账吧，简单来说，换了家公司，谈了一段感情</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>在技术上，自己真正算是开始做后端开发了吧，自己对中间件、缓存有了一个新的认识，但是进步缓慢。</p><p>在感情上，自己算是成熟一点，学会了怎么去爱一个人，学会了如何接纳自己，最重要的是很大程度上缓解了自己的内耗吧</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以前很喜欢写很长很长的文字，但是慢慢发现，懂得越多不是写的越多，而且经历的越多，思考的越多，感谢2021年的故事，有快乐、有悲伤、有痛苦、有释然，2022年加油，不要让自己犯同样的错误，朝着目标努力吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;2021年，对于世界来说都是一个魔幻的元年，新冠在全世界肆虐，然而每个中国人都被保护的很好&lt;/p&gt;
&lt;/block
      
    
    </summary>
    
      <category term="随想" scheme="https://mrzhangboss.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>泛型的前世今生</title>
    <link href="https://mrzhangboss.github.io/2021/12/10/java/%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>https://mrzhangboss.github.io/2021/12/10/java/泛型的前世今生/</id>
    <published>2021-12-10T12:35:08.000Z</published>
    <updated>2021-12-10T14:21:08.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是泛型"><a href="#一、什么是泛型" class="headerlink" title="一、什么是泛型"></a>一、什么是泛型</h2><h2 id="二、泛型的作用是什么"><a href="#二、泛型的作用是什么" class="headerlink" title="二、泛型的作用是什么"></a>二、泛型的作用是什么</h2><p>## </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、什么是泛型&quot;&gt;&lt;a href=&quot;#一、什么是泛型&quot; class=&quot;headerlink&quot; title=&quot;一、什么是泛型&quot;&gt;&lt;/a&gt;一、什么是泛型&lt;/h2&gt;&lt;h2 id=&quot;二、泛型的作用是什么&quot;&gt;&lt;a href=&quot;#二、泛型的作用是什么&quot; class=&quot;head
      
    
    </summary>
    
      <category term="Java" scheme="https://mrzhangboss.github.io/categories/Java/"/>
    
    
  </entry>
  
</feed>
