<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小伦子的笔记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mrzhangboss.github.io/"/>
  <updated>2021-06-15T00:54:12.033Z</updated>
  <id>https://mrzhangboss.github.io/</id>
  
  <author>
    <name>张伦</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第一封信</title>
    <link href="https://mrzhangboss.github.io/2021/06/15/letter/1/"/>
    <id>https://mrzhangboss.github.io/2021/06/15/letter/1/</id>
    <published>2021-06-14T23:57:33.000Z</published>
    <updated>2021-06-15T00:54:12.033Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="4329d5231ab81a720ab9f1be36d7b03f4b4750f629664eba63c496024f2368f3">995e50c340763ee1a325e8c3b289bb9412903aa8f2fc933eec9ae99a5646d7981d77d0f14a248f90afafe535a1a15cad16b7e1759adb1dc4cc118b4d5c3ed289344a2ebaa091eed7fdb9f2911e4c5972e2cdac2d0f824f07aa16b9677a1f111bb9fb12fcebc2c21d91c1ed12db6efc5ee2656e6187be7addec62aa60e734e06cb58e0f864c4ec62a080f4a2125588f6398b5cff4d5dad9bec83b4ba5e69c82dc271dbeebb20a0d323e43f724887008b9b1230d0a0461a9b423471a6ab1d72a2e0b6cff0f304481600156f7a650f237d34c5c4c7b1764e55d1b9e7bd548ba7cae19866f843e27a16e258475dcdf6fb1a047d4f4b93549219d5344865e4876054bdb34e4006ad0a1f083d6b3cc7abd6c2fdd497645645f4022215995e21b5fde7e0989721367c4969e94f651223dabd63a861cfee400f2400c4ea29fd900d5ace056de090c0748355874a9710897ef7d88c19c2547fb3c3bdaa60ac7162f0233c94c9c29eb3d203fd1dfeb2ace5f22199059aef59d4ff43169219f296577f77af91d3870191d13548f9bd9e3ef1973680a1d5a66e2e1557ac23ae1f35d40e539ace66c2a9bfa457c8a8cec4223344a346bac20320a76137255cbf67d516ea733b29d1cf750135f7d4050fda80b673799b87a122a1bc93f666aac47cdf1850fa9a60011c46863d6578848c011b45e68f36b61654ef50c426a7ee76029ffb3a799963da75f85eae47b47c3be177a607144c5de23875a74441d3c8a83d9785758b06f5f7d4da422f464419f05e47ef68d256cafb7ef751a0794f2d6aa5ec1b0e3f8f8871921a02e7f402426e5189338ed9636e5cccdb0798ad1c0affb9185314fd2af1d9f6cefa67d6d3fff8bf57aa0ab75089f4cf0a32dbc64f521dadd6d3417a35e512110e8df6954869545e1c246e2309160bdba36dd9e98adbd391576f18e47e92512a9943351050a37b28164188ad93b660d2d0cb754be69199fb7399d7b6cbdb515a40546efb055944111f35c9beb279e91a28c32085d4fa5542f31ec386cbe37f09146601986038442aec4b0dd4f630f1f6b0c7783edaf666426c9810b3ad5eb430a9e9e029633d0dbb787afec56e0a52d0d62c5c495dfb9e57a0d7111c583bbc94964b3a2c9ad01e97876829cd13fa47e63ef20849fe99870dae9356a71f272577feb21f8a1159aba58e67c5ef9218c074ca57365ea647d73e4f5f40c8762d3a1bcd012d4f1f12e5bd417500a9f85af07d2b40ba105cd406053858da444d6789a99c6bbb158459ac249671a625705fc527716c9bea41b170a5c685cf6a17f41da793924d4326bd2f9ffadcaee710d3db48bacbcd0883121ec073f4db15b7df8b8c2a6d4c1d44254bfa6bce49d26193e33bb6283e27289d083ac1643cd36c2b3b9a1eaf0eb89ac7b49442c3e00c850cf045b475548847b8c06dcc0b83487f65b1159a97854ef4a02299caaca32e48906f2c25ffba2b6f3011cc210da05c0d23e7b0f05bbf76c0c696b510a7e6ad4219c8135435504ece1bd4d1c423d8defcf79afd74ff7707f670ef49483bf860e7699ddf7e050a7cae5e67b9f4def20dd84b668eaf43f0b7bd075e831277771dc91b845651945cc6d6259050864c407c794835ae54c8f5fe0900f982f8c437a9da1f93df66f25fd19910592dc2dc6abd246b45c382476b242a26c648d10b6dc97b9373018cf0775e1004b79e9bf683ac3fdb2c6b74772ddae21bdc66fd52d0b6d568e774455228a02dc8b621ff072389fc801e03687a1aa206ae5e46a126b13a438c75fa27388c2c28245ab900fe5c55821a5ee3775b126ec505a9737b1ed6d9953d47043f1b506d5d53d8b7f6a6223bf0176f15d7048f2ac1cf1c30c451f72a0b7a261f41afe9a6451496d816a17e97ad7f4128b94c980589ddf106a161ae1f8064e98927973a39f104d88fb9521e70ce03463db271fb7e3a7e5d0facc6d7dda2486c1054d4069de225dc3816d6c6d68ad023496757cc1e54978080081c869daff48aae6f1285d0ee8121ac2725ef60bf151ea43d7661dbf32c5986bb5847e2e189ebfbbfa8c822de7966a001d83f4695032d42a48b9d8f822ee90a57e16e752f1036eee6d9d505e5bbefc2fbc18a67462b4c5fe751e40aec4b54e8d0c1f10d135c075116574476530554a42b11bff0b73ee00b616ff5973ab3c8b4aa10ffabc9176e24214075daf794fe081092c4772ddf91048d6187984cadedecac57d292ff926b0040bdacc077a0874507e0507a942a02cd394db08ad2e5d8bd8d591214829d8286df957cefefe57d5b20833a0eb849525c8aa2d94dca991e4b7177213658ea458dea229ca579098b58a8e5d2e99e8501ce14b8f7d4bf34309af7807d983bdcc455f6b933ed93905bf84f3648b18a74073f2acd237362de10ff6b81bd0ef231527b1eea24d393e91fa5a23d13d3f7e113a5d0bf56c135001d5277eda279d08b89f2a29e21d0254b83d73d9fef5d57fe9b29534325cd2e5281b9e87ff6f924daec111af5cc81f8a8e90ee2ca125e0cb2114d9d6d760f8ebb23d347bf768beb4926eb0dbfe33e440b173bca28987e15058bda0b7d688548dc02c2e1bda9ae6a9b4a3b29e7443535ad80fb3be87ffad4416171bee57dac795e7e4b5bc9af1687d6c5b6408588ea605e5310e7e5edd59b8cae1ee28ccefea293e5fa8bf1ade489e6653f922f919445e2b6355725fddf4d24ca37a2e4ee2e1ab80f1418ce20bc53d55ad2b145d938b67e01ff5024024fe04ee237bd98c18d4c559b01bc4b76920ccc7ac5ae21683ebfc4b79e8b816ac56e96875207fa37a7ce329e8d271f9cec8179f1293a988d5e7777f4ae07a866f22d7ed9cbebdb60a07e9d36cdffc29e2c042e2b64dd5fcbbcc2757ae0864a942c2684c4bbd8d8921f09939bb9e4c65a02adde4af219fc6e2195f63a379c77c032ba2307abf52dbdff569db792bef43c242dfec298cf5bc8129fa7e071f41792791df508050d093347b15982dd373a4fe6090526eefcb894011fdcb7c496fcbb14fd560083a8b8b429fef38c384258fc8ba92a334c89e522010b68ed3f6060d29ab272fb99f499847130ef559832df66bb97e5ff7b6b346fedee825695f270d3ad58faa62fc33627354217804522fb7019783837f596f68e21deab10c3e7adfb02a056bf1c2175f4f5c29b768a96551c02413e4470a64abb3d65c33c7f7cbd4c0e64adff64d110ef901c378db660f0c569a83c594d889531988d1429937662b84706ec26a21264f634eb223b8822c8f759915a061551cb48d76b4ce54165c48c0d35a6dfd1111ceb962eefadb6b5c9b3977deb1897a00b402771db4b770b5c18ebd8a3125ac5564296631352946f025a5c6cdfaea093db16c560ab876401f89bc8a2503f8bef0d6039ea77f609f315fb6915ce2726867df6f77cbdaab4dc2cb4fb03bb7a1608e3d1b3b03061abbdc83c0c3cc57ef800bb8afba0c0edbd9d98528891d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      这里有东西被加密了，需要输入密码查看哦。
    
    </summary>
    
      <category term="随想" scheme="https://mrzhangboss.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="信" scheme="https://mrzhangboss.github.io/tags/%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Stream源码（2）：从问题出发看源码</title>
    <link href="https://mrzhangboss.github.io/2021/05/23/java/stream/%E4%BB%8E%E9%97%AE%E9%A2%98%E5%87%BA%E5%8F%91%E7%9C%8B%E6%BA%90%E7%A0%81/"/>
    <id>https://mrzhangboss.github.io/2021/05/23/java/stream/从问题出发看源码/</id>
    <published>2021-05-23T01:48:54.000Z</published>
    <updated>2021-06-01T14:22:53.395Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前看一些开源项目源码的时候，发现一个问题，假如你贪全，一口气把整个代码看完，由于现在程序架构<br>比较复杂，很多功能被分成很多个组件来完成，有的时候你会被程序跳来跳去给弄晕，假如你但看一个小功能，你又<br>不知道为啥要用这个</p></blockquote><p>所以这次准备尝试从问题入手，首先给自己提一些<br>问题，然后在从源代码中寻找答案，<br>在寻找答案的过程中会遇到更多问题，就这样打破砂锅问到底，最终没有问题了，这个时候你就差不多看懂了</p><h2 id="0x00-问题"><a href="#0x00-问题" class="headerlink" title="0x00 问题"></a>0x00 问题</h2><ol><li>distinct 操作过程中是否会将新加入的元素和历史元素一一比较？</li></ol><p>为啥会有这个问题呢，因为在看源码</p><pre><code>Returns a stream consisting of the distinct elements (according to Object.equals(Object)) of this stream.For ordered streams, the selection of distinct elements is stable (for duplicated elements, the element appearing first in the encounter order is preserved.) For unordered streams, no stability guarantees are made.</code></pre><p>这句话意思是会依靠｀Object.equals(Object)｀　来去重，我们知道｀distinct｀和｀filter｀都是中间操作<br>难道<code>distinct</code>会将每个元素和历史元素做一个<code>Object.equals</code>调用吗</p><p>假如这样做的话，那么这个操作就是<code>O（n^2)</code>的时间复杂度了，显然不太靠谱，我们查看<code>distinct</code>源码发现</p><p>最终<code>distinct</code>生成了一个<code>StatefulOp</code> ，而且这个类存在一个<code>reduce</code>函数，其中声明了一个</p><pre><code>TerminalOp&lt;T, LinkedHashSet&lt;T&gt;&gt; reduceOp                = ReduceOps.&lt;T, LinkedHashSet&lt;T&gt;&gt;makeRef(LinkedHashSet::new, LinkedHashSet::add,                                                         LinkedHashSet::addAll);</code></pre><p>我们可以看到这个变量是一个终止操作，其中使用<code>LinkedHashSet</code>来进行聚合，所以看到这我们就猜测<br><code>Stream</code>没有这么傻，它声明了一个<code>LinkedHashSet</code>来存贮历史元素，这样只需要将加进来的元素进行<br>哈希计算，然后跟哈希碰撞的调用一下<code>Object.equals(Object)</code>函数就好了</p><p>我们看到这篇<a href="https://blog.csdn.net/puppylpg/article/details/78556730" target="_blank" rel="noopener">博文</a>的实验也证明我们的猜测了`  </p><p>接下来我们又有一个疑惑Stream内部是如何实现的呢？</p><h2 id="0x01-猜测"><a href="#0x01-猜测" class="headerlink" title="0x01 猜测"></a>0x01 猜测</h2><p>我们首先从最小的代码来看，我们首先来看一个无状态的stream函数</p><pre><code>Stream.of(1L, 2L, 3L, 4L).forEach(System.out::println)</code></pre><p>我们使用<code>for</code>循环用来实现也非常简单</p><pre><code> for (long l : new long[]{1L, 2L, 3L, 4L}) {  System.out.println(l);}</code></pre><p>接下来我们来思考，如何实现一个有状态的<code>Stream</code>流</p><pre><code>Stream.of(1L, 2L, 3L, 4L).reduce(0L, Long::sum);</code></pre><p>我们如何用<code>for</code>循环来实现呢，很简单，定义一个变量</p><pre><code>long begin = 0;for (long l : new long[]{1L, 2L, 3L, 4L}) {    begin += l;}</code></pre><p>我们能很容易写出一层for循环，但是Stream强大的地方在于，他可以穿插很多函数处理<br>比如：</p><pre><code>Stream.of(1L, 2L, 3L, 4L, 4L, 5L, 5L).distinct().filter(x -&gt; x &gt; 2).reduce(0, Long::sum);</code></pre><p>我们简单的穿插了<code>distinct</code>和<code>filter</code>操作，我们接下来尝试使用<code>for</code>循环来实现上面的<code>Stream</code></p><p>首先我们知道<code>distinct</code> 需要一个<code>Set</code>来过滤已经存在的，其中<code>reduce</code>需要一个初始量，那就好做了</p><pre><code>long start = 0L;for (long l : new long[]{1L, 2L, 3L, 4L}) {    if(!set.contains(l)) {        set.add(l);        if(l &gt; 2) {            start += l;        }    }}</code></pre><h2 id="00x02-源码探究"><a href="#00x02-源码探究" class="headerlink" title="00x02 源码探究"></a>00x02 源码探究</h2><p>接下来我们看看<code>Stream</code>内部如何实现这个<code>for</code>循环的，我们可以看到，其实<code>.distinct().filter(x -&gt; x &gt; 2).reduce(0, Long::sum)</code>对于每一层我们都需要能<br>创建一个<code>Sink</code>，对于这个<code>for</code>循环来说，都是把每个数据，我们把数据从一个<code>sink</code>到其他的<code>sink</code></p><p>所有的<code>Sink</code>都实现了<code>Consumer</code> 接口，其中最重要的接口就是</p><pre><code>void accept(T t);</code></pre><p>这个消费接口，我们可以理解“吃”数据，它会把我们传给它的值都“消化”掉</p><p>当我们在创建<code>.distinct().filter(...)...</code>这些stream的时候，我们做了什么呢，<br>我们每进行一次中间操作，我们都新建了一个流，其中我们通过<code>upstream</code> 这个变量指向<br>之前的流</p><p>当我们碰到终止操作比如<code>reduce</code>的时候，我们会进行一个回溯，把所有<code>upstream</code>都进行回溯，反过来把一个<code>sink</code>组装起来（每个sink指向它的上游）</p><pre><code>// java.util.stream.AbstractPipeline.classfinal &lt;P_IN&gt; Sink&lt;P_IN&gt; wrapSink(Sink&lt;E_OUT&gt; sink) {    Objects.requireNonNull(sink);    // 回溯之前的stream流，创建sink，并让当前的sink指向上流    for ( @SuppressWarnings(&quot;rawtypes&quot;) AbstractPipeline p=AbstractPipeline.this; p.depth &gt; 0; p=p.previousStage) {        sink = p.opWrapSink(p.previousStage.combinedFlags, sink);    }    return (Sink&lt;P_IN&gt;) sink;}</code></pre><p>最终我们得到了最上流的sink，以上面为例就是<code>distinct</code>那个sink</p><p>接下来我们执行<code>for</code>循环，其中最重要的就是</p><pre><code>// java.util.stream.AbstractPipeline.copyInto 函数// 执行for循环 其中 传入的sink就是 我们上面得到的像葫芦串一样的sinkspliterator.forEachRemaining(wrappedSink)</code></pre><p>我们只需要给<code>wrappedSink</code>传入<code>for</code>循环的值就好了，由于每个sink都有其上游的引用，比如说<code>distinct</code>的sink，<br>他会判断是否已经存贮在<code>sink</code>中，如果没有就往上游传，由于上游也是个<code>sink</code>，所以最终如果不传了或者到最上游了就继续下一<code>for</code>循环的值</p><h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><p>总结，我们这边非常浅显的把源代码给介绍了一下，其实要想吃透最好使用debug功能，一行一行代码进行debug，这样就能印象更深刻</p><p>##　引用</p><ul><li><a href="https://blog.csdn.net/puppylpg/article/details/78556730" target="_blank" rel="noopener">对Java8中distinct()的思考</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;之前看一些开源项目源码的时候，发现一个问题，假如你贪全，一口气把整个代码看完，由于现在程序架构&lt;br&gt;比较复杂，很多功能被分成很多个组件来完成，有的时候你会被程序跳来跳去给弄晕，假如你但看一个小功能，你又&lt;br&gt;不知道为啥要用这个&lt;/p&gt;
&lt;/bl
      
    
    </summary>
    
      <category term="Java" scheme="https://mrzhangboss.github.io/categories/Java/"/>
    
    
      <category term="Stream" scheme="https://mrzhangboss.github.io/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>Stream源码（1）：如何实现去重</title>
    <link href="https://mrzhangboss.github.io/2021/05/15/java/stream/%E4%BB%8E%E5%8E%BB%E9%87%8D%E5%88%B0Stream%E6%BA%90%E7%A0%81/"/>
    <id>https://mrzhangboss.github.io/2021/05/15/java/stream/从去重到Stream源码/</id>
    <published>2021-05-15T14:48:20.000Z</published>
    <updated>2021-05-20T15:24:05.152Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇博客是在看代码的时候看到使用Java8使用<code>Stream</code>去重的妙用，从而对Java如何使用Stream实现几行代码<br>完成一个可支持并行化的流式计算程序</p></blockquote><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>什么是<code>Stream</code></p></blockquote><p>简单来说<code>Stream</code>就是Java8引入的一种流式API，让只需要定义一些处理函数就能优雅的对集合的一些操作</p><p>举个栗子，之前我们想遍历打印所有的参数我们得写下面代码</p><pre><code>for (int i : new int[]{1, 2, 3, 4}) {    System.out.println(i);}</code></pre><p>假如使用Java8，我们只需要一行代码</p><pre><code>Arrays.stream(new int[]{1, 2, 3, 4}).forEach(System.out::println);</code></pre><p>我们只需要定义一个函数，其他的<code>Stream</code>帮我们解决</p><h2 id="Stream模型"><a href="#Stream模型" class="headerlink" title="Stream模型"></a>Stream模型</h2><p>简单来说<code>Stream</code>把操作分为两张，一种是中间操作，一种是终结操作</p><p>中间操作你可以把他看做对数据源的一种处理，而终结操作是定义产生新数据过程，简单来说，假如我们有一堆苹果<br>需要处理，我们使用一个流水线来对经过的苹果进行各种处理（中间操作），丢掉烂掉的（filter），削掉皮（map）等等，<br>最后的我们需要对苹果进行装箱（终结操作）</p><h2 id="分析功能"><a href="#分析功能" class="headerlink" title="分析功能"></a>分析功能</h2><p>我们接下来看看我们需要实现的功能，就是去重，我们知道<code>Stream</code>其实提供了一个<code>distinct</code>方法中间操作来帮我们实现去重功能，<br>对于基本类型比如<code>String</code>，<code>Integer</code>，<code>Long</code>这些我们能很容易进行去重，但是对于复杂类，我们得<br>重写<code>hashCode</code>和<code>equal</code>方法来支持去重操作了，对于集合内的每个数据都会用<code>equal</code>来进行去重</p><p>接下来我们尝试直接使用终结操作<code>collect</code>来解决掉<br>怎么做呢，<code>collect</code>其实也很简单就是创建一个容器，把数据装进去，我们就只需要使用一个可以支持去重操作的<br>容器来做就好了</p><p>支持去重的有<code>Map</code>和<code>Set</code>，所以我们想到的第一个方法就是将流变成一个<code>Set</code>，这个也是网上很多人提供的一个版本</p><pre><code>dishes.stream().distinct().collect(Collectors.toCollection(            () -&gt; new TreeSet&lt;&gt;(Comparator.comparing(Dish::getType)))</code></pre><p>我们把这行代码给分解成两行</p><pre><code>TreeSet&lt;Dish&gt; container = new TreeSet&lt;&gt;(Comparator.comparing(Dish::getType));dishes.stream().collect(Collectors.toCollection(() -&gt; container));</code></pre><p>第一行其实就是声明了一个容器，核心代码就是 <code>() -&gt; container</code> 我们传入一个容器，让他来存贮，我们使用<br><code>TreeSet</code>的一个构造器，它只需要传入一个函数，他会比较传进来的每个值，假如发现已经存在了它就不会插入了</p><p>但是这个有个问题就是，他只能选择第一个出现的</p><p>接下来我们试试用<code>Map</code>，</p><pre><code>dishes.stream().collect(toMap(Dish::getType, d -&gt; d);</code></pre><p>我们写下下面的代码，但是这个代码有点问题就是假如出现重复的，他会抛异常，因为程序默认不知道你想要哪个数据</p><pre><code>dishes.stream().collect(toMap(Dish::getType, d -&gt; d, (oldData, newData) -&gt; oldData));</code></pre><p>我们可以传入一个选择函数，这样当发现重复的时候就可以选择要哪个插入到map中去，这个也解决了上面使用<code>Set</code>来存贮的时候没法选择到底是新来的还是后来的</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇博客简单的介绍了实现去重功能的三种实现方法，接下来这个系列的博客会深入到源码来探究Java8如何实现<br>Stream这么多功能的</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://cloud.tencent.com/developer/article/1756399" target="_blank" rel="noopener">Java Stream 源码分析</a></li><li><a href="https://www.jianshu.com/p/3219f184bb8e" target="_blank" rel="noopener">JAVA8优雅的去重</a></li><li><a href="https://club.perfma.com/article/116123" target="_blank" rel="noopener">JAVA8Stream 源码分析2</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本篇博客是在看代码的时候看到使用Java8使用&lt;code&gt;Stream&lt;/code&gt;去重的妙用，从而对Java如何使用Stream实现几行代码&lt;br&gt;完成一个可支持并行化的流式计算程序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Java" scheme="https://mrzhangboss.github.io/categories/Java/"/>
    
    
      <category term="Stream" scheme="https://mrzhangboss.github.io/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>周末杂思</title>
    <link href="https://mrzhangboss.github.io/2021/05/15/summary/%E5%91%A8%E6%9C%AB%E6%9D%82%E6%80%9D/"/>
    <id>https://mrzhangboss.github.io/2021/05/15/summary/周末杂思/</id>
    <published>2021-05-15T08:27:29.000Z</published>
    <updated>2021-05-15T08:28:01.533Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL Group By 还可以用来去重</title>
    <link href="https://mrzhangboss.github.io/2021/04/05/java/mysql/GroupByAsSort/"/>
    <id>https://mrzhangboss.github.io/2021/04/05/java/mysql/GroupByAsSort/</id>
    <published>2021-04-05T02:29:00.000Z</published>
    <updated>2021-04-05T03:43:41.926Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在接手老项目的时候，看到一个SQL： <code>select * from xx group by id</code>，<br>当时一看到这句就感觉，这个group by是不是多余的，既然select 全部了，那去掉其实也无所谓，<br>然后询问上一个接手的同事才知道这个是用来去重了，好家伙，以前一直用来分组统计的语句竟然可以用来<br>去重，涨知识了</p></blockquote><h2 id="Group-By-到底可不可以去重呢"><a href="#Group-By-到底可不可以去重呢" class="headerlink" title="Group By 到底可不可以去重呢"></a>Group By 到底可不可以去重呢</h2><p>首先我们新建一个测试表，并插入一些测试数据</p><pre><code>CREATE TABLE test.student (  `sno` varchar(20) NOT NULL,  `sname` varchar(20) DEFAULT NULL,  `ssex` varchar(20) DEFAULT NULL,  `sage` int(11) DEFAULT NULL,  `sdept` varchar(20) DEFAULT NULL,  PRIMARY KEY (`sno`));INSERT INTO test.student (sno, sname, ssex, sage, sdept) VALUES (&apos;201215121&apos;, &apos;李勇&apos;, &apos;男&apos;, 20, &apos;CS&apos;);INSERT INTO test.student (sno, sname, ssex, sage, sdept) VALUES (&apos;201215122&apos;, &apos;刘晨&apos;, &apos;女&apos;, 19, &apos;CS&apos;);INSERT INTO test.student (sno, sname, ssex, sage, sdept) VALUES (&apos;201215123&apos;, &apos;王敏&apos;, &apos;女&apos;, 18, &apos;MA&apos;);INSERT INTO test.student (sno, sname, ssex, sage, sdept) VALUES (&apos;201215124&apos;, &apos;张立&apos;, &apos;男&apos;, 19, &apos;IS&apos;);INSERT INTO test.student (sno, sname, ssex, sage, sdept) VALUES (&apos;201215125&apos;, &apos;张立&apos;, &apos;男&apos;, 19, &apos;IS&apos;);</code></pre><p>然后我们测试一些是否可以去重</p><pre><code>mysql&gt; SELECT * from test.student GROUP BY ssex ;ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &apos;test.student.sno&apos; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by</code></pre><p>哎呀出错了，意思是不支持，因为我们<code>sql_mode</code> 设置了<code>only_full_group_by</code>这个，我们来看看我们<code>sql_mode</code>里面有啥</p><pre><code>mysql&gt; SELECT @@SESSION.sql_mode \G;*************************** 1. row ***************************@@SESSION.sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION1 row in set (0.00 sec)</code></pre><p>的确我们<code>sql_mode</code>是设置了<code>ONLY_FULL_GROUP_BY</code>这个值，这个<code>sql_mode</code>是啥呢，首先我们知道<br>MySQL只是SQL一种实现软件，他为了和其他SQL兼容，就设置了这个变量，你可以通过<br>修改这个值来修改他的语法支持</p><p>其实<code>group by</code>本来的意图就是一个聚合函数，正常来说，我们一般是使用下面的语法</p><pre><code>select a, count(*) from xxx group by a</code></pre><p>但是<code>MySQL</code>非常开放，它允许你使用非group by 字段，在5.7之前都是默认允许的，但是5.7之后，它默认关闭了<br>但是你可以修改关闭</p><p>接下来我们临时关闭掉这个，怎么关闭呢，非常简单，把<code>ONLY_FULL_GROUP_BY</code>在<code>sql_mode</code> 删除就好了<br>接下面执行下面语句</p><pre><code>set sql_mode =(SELECT replace(@@SESSION.sql_mode, &apos;ONLY_FULL_GROUP_BY,&apos;, &apos;&apos;));</code></pre><p>然后我们再执行上面<code>sql</code></p><pre><code>mysql&gt; SELECT * from test.student GROUP BY ssex ;+-----------+--------+------+------+-------+| sno       | sname  | ssex | sage | sdept |+-----------+--------+------+------+-------+| 201215122 | 刘晨   | 女   |   19 | CS    || 201215121 | 李勇   | 男   |   20 | CS    |+-----------+--------+------+------+-------+2 rows in set (0.00 sec)</code></pre><p>o了，我们再看看我们目前的<code>sql_mode</code></p><pre><code>mysql&gt; SELECT @@SESSION.sql_mode;+------------------------------------------------------------------------------------------------------------------------+| @@SESSION.sql_mode                                                                                                     |+------------------------------------------------------------------------------------------------------------------------+| STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION |+------------------------------------------------------------------------------------------------------------------------+</code></pre><p>的确目前看到<code>ONLY_FULL_GROUP_BY</code>这个了，而且我们发现的确去重了</p><h2 id="Distinct和Group-By"><a href="#Distinct和Group-By" class="headerlink" title="Distinct和Group By"></a>Distinct和Group By</h2><p>通过上面的实验我们知道了，<code>Group By</code>的确可以去重，但是我们去重一般使用<code>Distinct</code>来，<br><code>Distinct</code>原理很简单</p><p>我们执行下面语句</p><pre><code>mysql&gt; explain SELECT distinct ssex from test.student ;+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------+| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------+|  1 | SIMPLE      | student | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    5 |   100.00 | Using temporary |+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------+</code></pre><p>我们可以看到<code>Using temporary</code>告诉我们，就是创建一个临时表，然后把<br><code>Distinct</code>的字段从表里取出来，然后返回给客户端就好了</p><p>我们看看<code>Group By</code>的原理</p><pre><code>mysql&gt; explain SELECT * from test.student GROUP BY ssex ;+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                           |+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+|  1 | SIMPLE      | student | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    5 |   100.00 | Using temporary; Using filesort |+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+</code></pre><p>我们也看到了<code>Using temporary;</code>，其实<code>Group By</code>底层也是用到临时表，把你<code>Group By</code>的值当<br>做主键，而且我们看到默认它会取第一个出现的值作为最终的值<br>这个是为什么呢</p><h2 id="Group-By-原理解析"><a href="#Group-By-原理解析" class="headerlink" title="Group By 原理解析"></a>Group By 原理解析</h2><p>我们前面知道，<code>Group By</code> 一开始只是用来做聚合函数的，所以底层上最开始设计的时候就是</p><ul><li>首先建一张临时表，把<code>Group By</code>字段作为唯一主键（下面称作key）</li><li>然后把原始表中所有数据按照key进行分组</li><li>对分组内数据一个一个进行聚合，比如执行<code>count</code>, <code>avg</code> 等等函数，最后每组跟随主键key产生最终的一列值</li><li>最后对临时表进行排序返回</li></ul><p>所以其实当时为了支持，不在主键内的值，MySQL只是简单的把组内第一个出现值赋值进去</p><p>那为什么不把最后组内最后一个值赋值进去呢，首先是如果实现这个功能，想当于组内数据要全部执行一遍，<br>效率太低了，那有没有办法能实现去重的时候取组内最后一个呢</p><p>首先说目前是不支持的，不过能通过下面两种方式来实现</p><p><strong>方法一：</strong></p><p>首先把你想要的数据进行排序</p><pre><code>create temporary table test.tt as SELECT * from test.student order by sno desc;</code></pre><p>然后我们看正常来按照年龄排序</p><pre><code>mysql&gt; SELECT * from test.student GROUP BY sage;+-----------+--------+------+------+-------+| sno       | sname  | ssex | sage | sdept |+-----------+--------+------+------+-------+| 201215123 | 王敏   | 女   |   18 | MA    || 201215122 | 刘晨   | 女   |   19 | CS    || 201215121 | 李勇   | 男   |   20 | CS    |+-----------+--------+------+------+-------+3 rows in set (0.00 sec)</code></pre><p>接下来我们再看看我们去重取最后一个出现的，我们看到<code>19</code>的<code>张立</code>取代了第一个出现的<code>刘晨</code></p><pre><code>mysql&gt; SELECT * from test.tt GROUP BY sage;+-----------+--------+------+------+-------+| sno       | sname  | ssex | sage | sdept |+-----------+--------+------+------+-------+| 201215123 | 王敏   | 女   |   18 | MA    || 201215125 | 张立   | 男   |   19 | IS    || 201215121 | 李勇   | 男   |   20 | CS    |+-----------+--------+------+------+-------+3 rows in set (0.00 sec)</code></pre><p><strong>方法二：</strong></p><p>第二种方法其实把上面两个步骤合成一个，首先我们把原始数据进行排序，然后取出组内第一个</p><pre><code>select sno, sname, sage, sdeptfrom (SELECT @i := if(@sage &lt;&gt; sage, 0, @i + 1) as i, @sage := sage, a.*from (select * from test.student order by sage, sno desc) a) awhere i = 0order by sage;</code></pre><p>我们用上面这行函数模仿了，<code>Group By</code>去重，我们可以看到我们在末尾加了一个<code>order by sage</code><br>语句，这是因为默认<code>Group By</code>会按照<code>Group By</code>的键值给我们排序，<br>所以如果你想优化<code>Group By</code>性能，当你对组排序顺序无所谓的时候，你可以在<br><code>Group By</code> 末尾加上<code>order by null</code>关闭排序功能</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Group By</code>去重功能在<code>5.7</code>之后就默认关闭了，所以其实大家用来做去重还是慎用，不过通过这个功能去探索<br>底层原理对你数据库性能优化还是非常有帮助的</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul><li><a href="https://blog.csdn.net/Dax1n/article/details/86581472" title="MySQL中的Group By是否允许SELECT非聚合列的总结" target="_blank" rel="noopener">MySQL中的Group By是否允许SELECT非聚合列的总结</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_only_full_group_by" title="mysql5.7文档" target="_blank" rel="noopener">mysql5.7官方文档</a></li><li><a href="https://www.itzhai.com/articles/how-sql-works-understand-the-essence-of-tuning-by-the-execution-principle.html" title="SQL运行内幕：从执行原理看调优的本质" target="_blank" rel="noopener">SQL运行内幕：从执行原理看调优的本质</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近在接手老项目的时候，看到一个SQL： &lt;code&gt;select * from xx group by id&lt;/code&gt;，&lt;br&gt;当时一看到这句就感觉，这个group by是不是多余的，既然select 全部了，那去掉其实也无所谓，&lt;br&gt;然后
      
    
    </summary>
    
      <category term="Java" scheme="https://mrzhangboss.github.io/categories/Java/"/>
    
    
      <category term="MySQL SQL" scheme="https://mrzhangboss.github.io/tags/MySQL-SQL/"/>
    
  </entry>
  
  <entry>
    <title>从因材施教的角度来看写博客</title>
    <link href="https://mrzhangboss.github.io/2021/04/04/summary/stage/how2writewell/"/>
    <id>https://mrzhangboss.github.io/2021/04/04/summary/stage/how2writewell/</id>
    <published>2021-04-04T06:32:35.000Z</published>
    <updated>2021-04-04T09:37:34.608Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一开始本来想写一篇反思自己最近文章比较浅显的博客，但是想着想着突然发现其实这样的<br>反思我已经写过很多篇了，但是效果不好，这篇博客从另外一种角度来思考如何让自己<br>写出好博客</p></blockquote><h2 id="什么是因材施教"><a href="#什么是因材施教" class="headerlink" title="什么是因材施教"></a>什么是因材施教</h2><p>目前我们的教育算不上是因材施教，每个人上的同样的课本，同一老师传道受业</p><p>我上学的那会经常上课开小差，倒不是因为听不懂老师的内容，而是因为老师讲的我都会了，我的思维要比<br>一般的人来的要活跃一点</p><p>但是那个时候老师只是告诉我们，上课开小差是不对的</p><p>假如我回到过去，给自己上课，我会引导自己思考更多，这道题为什么这样做，还能怎么做，而不是单纯的给<br>我一个答案，说这道题就是这么做</p><p>其实因材施教就是顺势而为，思维活跃的就是给他们更大的挑战，让他们自己去钻研原理</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>其实回到现在，我们仍然还是处于学生状态，可能因为我们受了很多年的素质教育，所以<br>当我们自己开始当自己的老师的时候，去自学，还是延续当初自己的学习状态</p><p>那怎么才能做到因材施教呢，其实很简单，找到一种自己最喜欢的学习方式，而不是强迫自己<br>去学习，去听课，去学新的东西</p><p>对于我来说，最好的学习方式是激起我的好奇心，学新东西的时候，有些部分可能之前学过，你可以<br>不断的给自己“抬杠”，激发自己的好奇心，去探究，但是还有一个非常重要的一点就是<br>得及时把自己拉回来，避免一条路走到黑，因为有的时候你会发现随着你”钻“牛角尖越来越深，<br>你会精疲力竭，你得稍作休息，这个时候做个总结，总结自己所得，以及评估继续钻下去是否<br>值得</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这段时间其实自己一直处于一种很焦虑的状态，很想一口气吃成大胖子，因为自己目前其实算是转行吧，之前一直在做<br>数据分析、大数据，目前转成后端，对于我来说我想在这个行业闯出一番事业来</p><p>之前一直以被动的学习姿态去重新学习后端，搞的自己非常压抑，这段时间休息好好思考了一下，有的时候我就像对自己<br>实施了”棍棒教育“，强迫自己努力学习，但是大可不必，自己本来是喜欢这个行业的，自己这种强势的思想反而会<br>让我产生不想去学的态度，其实把学习当做一个有挑战性的事，快乐的学习比啥都重要</p><h2 id="反思-1"><a href="#反思-1" class="headerlink" title="反思"></a>反思</h2><p>其实我自己反思，自己最大的一个问题就是犯了一个年轻人经常犯“好高骛远”</p><p>回看我自己从大学到现在，自己一直在拼命的学，自己一直在给自己定目标，碰到新东西一定要把它<br>快速掌握</p><p>甚至到现在，我还是这样，自己想成为后端专家，所以自己一直在“催促”自己抓紧把知识点掌握，<br>在知乎上看了很多后端专家需要掌握的知识点，自己为了快速掌握，催促自己赶快把这篇文章给<br>看懂</p><p>其实最大的一个问题就是我太急了，无论学什么东西都是囫囵吞枣</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一开始本来想写一篇反思自己最近文章比较浅显的博客，但是想着想着突然发现其实这样的&lt;br&gt;反思我已经写过很多篇了，但是效果不好，这篇博客从另外一种角度来思考如何让自己&lt;br&gt;写出好博客&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是因材施
      
    
    </summary>
    
      <category term="随想" scheme="https://mrzhangboss.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>新工作两周总结</title>
    <link href="https://mrzhangboss.github.io/2021/04/02/summary/stage/2weekSummay/"/>
    <id>https://mrzhangboss.github.io/2021/04/02/summary/stage/2weekSummay/</id>
    <published>2021-04-02T13:44:55.000Z</published>
    <updated>2021-04-02T14:29:12.163Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一眨眼2周就过去了，在新的公司感触颇多</p></blockquote><h2 id="改变"><a href="#改变" class="headerlink" title="改变"></a>改变</h2><ul><li>工作流程</li></ul><p>新的公司比原来要大的多，业务也比之前要多的多，业务多之前在小公司都是一把梭，什么测试开发运维都是自己上，<br>但是这边没法全干，每个人都有自己的工作</p><p>这个带来一个好处就是你可以专心自己的业务，但是也带来一个坏处，就是想做一件事得协调很多个部门</p><p>而且当你想做一个大功能的时候就得开会了，这个也是我的一个很大的感受了吧，会议越来越多，之前半年才开一次会，现在一天就开两次</p><ul><li>部署流程</li></ul><p>之前由于一般都是个人负责一个大的项目，一般都是自己选择最方便的发布方式来部署应用，但是随着公司越来越大，你得考虑到<br>各种情况，所以这边采用了K8S + Dubbo 这种来部署分布式应用</p><p>底层还是普通的运行方式，但是采用了云原生镜像这种来隔离应用，以及对应用动态扩容，当然我们我们采用的是<br>云服务，基本上所有的组件都是云组件，理论上，我们是一个完全在云上的公司</p><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>目前公司是完全2C的公司，而且目前我负责的部分是主要是公共服务，所以其实整体业务并没有太多复杂性的东西，<br>但是2C最重要的一个问题就是，很在乎用户体验，应用的稳定性非常重要</p><p>经过两周的磨合，我对公司的架构有个大致的了解，但是涉及到的一些组件，大部分只是会使用，目前自己需要加强对组件<br>的了解，尽快上手业务，目前公司的自动化测试也存在不足（或者是没有），自己接下来的打算就是<br>尽快扩展自己的知识树，把用到微服务组件给钻透，而不是仅仅停留在会使用的阶段</p><p>这样第一个不会因为自己一些知识的欠缺而引起系统事故（听说P0事故就得背书包走人了哈哈），第二个也能让自己尽快<br>提升到下一个级别</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这两周自己在leader的建议下也尝试在使用UML来归纳总结自己的知识，目前只能说真香，但是的确得完全掌握透才能<br>完成整体架构的理解</p><p>目前自己新概念也已经背到22篇了，每天背完并默写还是有一定成就感的，其实刚入职这段时间自己一直有点焦急，首先<br>是因为，刚入职，害怕自己写着写着就背书包走人了，但是还好其实leader和同事都挺好的，</p><p>但是自己发现自己有的时候的确急了一点，总想把事情给赶完，太过急躁其实也不好，太过松散也不好，尽力而为，<br>才是最好</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一眨眼2周就过去了，在新的公司感触颇多&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;改变&quot;&gt;&lt;a href=&quot;#改变&quot; class=&quot;headerlink&quot; title=&quot;改变&quot;&gt;&lt;/a&gt;改变&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;工作流程&lt;/li&gt;

      
    
    </summary>
    
      <category term="随想" scheme="https://mrzhangboss.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>Dubbo浅探</title>
    <link href="https://mrzhangboss.github.io/2021/03/27/java/dubbo/dubbo%E6%B5%85%E6%8E%A2/"/>
    <id>https://mrzhangboss.github.io/2021/03/27/java/dubbo/dubbo浅探/</id>
    <published>2021-03-27T13:27:53.000Z</published>
    <updated>2021-03-28T08:17:45.558Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>繁忙的一周终于过去了，加入小影第一周主要是熟悉后端架构，同事们都挺好，自己的基础还是有点弱，前段时间简单的把Spring<br>Cloud 和 Dubbo学习了一下，但是其实对于工作来说，之前学的都是最新的版本，但是其实公司用的版本很老了，所以需要时间去学习老版本</p></blockquote><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>首先我们来看看Dubbo的历史，看Dubbo的历史的时候我们得先看看<a href="https://www.jianshu.com/p/cad51a09d0c2" title="Dubbo发展史" target="_blank" rel="noopener">Spring的历史</a>,2004年就出来了Spring1.0，随着<br>一些网站越做越大，例如淘宝，随着用户量越来越大，单一Spring无法支持他们的体量，<br>所以淘宝基于Spring开发了Dubbo这个架构</p><p>Dubbo和Spring有什么不同，Dubbo其实是基于Spring开发的，只不过他和普通的Spring程序不一样，它提供的是<br>分布式服务框架</p><p>原来的Spring程序放进Tomcat里面就可以跑了，但是Dubbo是将一堆Spring程序组合起来做一个分布式系统，<br>他提供了什么呢，总结起来就是Spring程序的互识和通信</p><p><img src="/images/dubbo-struct.png" alt="Dubbo架构图"></p><p>Dubbo使用起来非常简单，复杂的注册和监控已经帮你写了，你只要启动提供者（Provider）和消费者（Consumer）实例就好了</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>其实仔细看看整个架构，什么是提供者和消费者，之前我们写web，很简单一个url对应一个接口</p><p>但是想想随着公司越来越大，小公司用户量不大直接发布新代码上线就好了，大公司需要24小时提供服务，所以Dubbo首先<br>做的就是将后端分层，逻辑需要经常变动的给独立开来，我们把原来的接口分成两个一个是提供者和一个是消费者</p><p>提供者负责承担真正的代码逻辑，消费者只是提供调用的接口，这样每次代码上线的时候，只需要把新提供者注册进注册中心，<br>然后把老提供者下线，这样就无感知的将新版本替换成老版本了</p><h2 id="微服务区别"><a href="#微服务区别" class="headerlink" title="微服务区别"></a>微服务区别</h2><p>随着Spring Cloud从2016年的兴起，微服务的风潮开始兴起，那么Dubbo和Spring Cloud有什么不同呢，首先<br>Dubbo和Spring Cloud的设计理念是不一样的</p><p>首先Dubbo它想做的是一个Rpc框架，它提供Spring 消费者和提供者之间的通信，借此打造分布式集群，而<br>Spring Cloud做的是一种切分，它将系统切分成每个小的服务，每个服务负责的部分都不一样</p><p>简单来说就是，Spring Cloud提供的积木，你可以自己组装一个系统，它也不关心你用不用什么组件，单独来看，<br>每个Spring Cloud服务都是一个网站，他们之间用HTTP进行通信</p><p>Dubbo呢，考虑的更多是各个服务之间高效的通信，你可以理解为Dubbo是做一层网络中间件，这给他自己带来了一定的限制<br>而Spring Cloud本质上还是一个个网站，所以你可以很容易在里面搭建配置中心，网关，服务跟踪等等</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Dubbo出生在2011年，那个时候云服务还没有兴起，网络流量还很贵，Spring Cloud出生在2016年，正是云、Docker、K8S这些组件的大热的时候，<br>大家发现在一个系统中流量是最不值钱的，反而一个系统更加灵活更加好调试才更符合</p><p>但是很多老系统都在使用Dubbo作为系统架构， 所以阿里推出了Spring Cloud Alibaba，即可以兼容原来的Dubbo系统，也可以很轻松将原来的Dubbo架构<br>迁移到Spring Cloud的架构</p><p>##　资料</p><p><a href="https://www.jianshu.com/p/cad51a09d0c2" title="Dubbo发展史" target="_blank" rel="noopener">Spring的历史</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;繁忙的一周终于过去了，加入小影第一周主要是熟悉后端架构，同事们都挺好，自己的基础还是有点弱，前段时间简单的把Spring&lt;br&gt;Cloud 和 Dubbo学习了一下，但是其实对于工作来说，之前学的都是最新的版本，但是其实公司用的版本很老了，所以需要
      
    
    </summary>
    
      <category term="Java" scheme="https://mrzhangboss.github.io/categories/Java/"/>
    
    
      <category term="SpringCloud  Dobbo" scheme="https://mrzhangboss.github.io/tags/SpringCloud-Dobbo/"/>
    
  </entry>
  
  <entry>
    <title>人生浅思</title>
    <link href="https://mrzhangboss.github.io/2021/03/27/secret/%E4%BA%BA%E7%94%9F%E6%B5%85%E6%80%9D/"/>
    <id>https://mrzhangboss.github.io/2021/03/27/secret/人生浅思/</id>
    <published>2021-03-27T13:25:03.000Z</published>
    <updated>2021-03-28T02:31:53.177Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="72e89f2c84578a62f7f4d0614eda425cb6057f9285508b5a84f1060f8dbc4c89">4f2ee425f9beb83069b565b3c5ad5cc44f766a90c472399a0616d746a9b183d0467c4f2cdeba5e270614a1527105157260efe7ad69161c35cf1dd1817cf437b2d28801d94005eca39ada0b32c97d37ae3c68b1e9d4c0c5aff2ddf8835314231296ee092f38e57383265a362ed1f652a92f9c935f1b9aec0f69ec5bd044661a163094ae81cccf0528e715ea110bee71a19ac8ed0a1840a78a7d513bcc1cbd8a10c21db1895d15086c918ae92d97171dc5c1a76f8915447d8ba95263bc4135012627a9e1a2e597e94757342ef2b363bb7b4802e03739fb6a86aa1e988e62198adcccb9474c08dd230071e4f665c88a87426d807453c21c5562edee6d8237d65d10bc869aa242dd0275e986c289fb4b53720c9412d79e81ae63cd28a313ffdfc314c11c21d419da1c756422995d0c87bc74991ee474f5115cb8920095b8b74aab0c1ef1b1dabf869859c9be8b1b368c7421e94a9fdc96dcd1e2bb208f57f3b873053e968998c4b6b74363f41a7b0146afb0c96a67425e3554a5f6c3a4872ad77672fc41dfa3c1e9a2f796618d087c09611389ac6c8ac50a220acd14b932d347d8c9e66f724e7a6208f902423d0d553f07546c922716eb012999e1dd6246ba1f34bb9ed455ff4e431ea82ffcd644f65fbc3f3b80991181067e101660b137641c86c5c45fc52b7a1c34eb8ba825b5a215c2583ce64a8c597390baf27233b41beb2afc0f1249a8b422079a7cb55e1ec24fa713044a15ef7ae856e11fda7335fd46d10796c87509058cd32be074fbc70a8e7ca6c86507a0b331df7470be0246316245d9bcb88472d36131545a050c389c3c2330028ff72f791b6b61ebd09b3e166827896c0b977b033300f191e253b616a9f6e0f81fe076472f040f1dfbb7a79381d7ffcd7c2b9d6844e045a63cf4b64586597bf0c85e2fc1346dd4b4c598c4ac864ea11b2289c323a915565e55873d46f1e6d887a338e55a631db25c6e129678e30aa7953cc9d8a976cda50fac47e988b03267143fa1e4073832a71f4ef2aaf0d2f9428fea3a59a23e3bf5c9b95f28e397d062009b89db254fb12dd6285651b1a0468d1ead0925e8df756a0b417f3b3142475a8cbd53831dd81a9ddaa61b8c4d9b223566813e54514a5cc3525d24a9870f5641e2c8e31fab6c009f24417864bb2bc6a998f1db9ca98cd063dd64728e479da077be45e0d609a948657503851f1d93125d37978381c6ebc5cba8e0f154831b44d43a49ef313ce2653b3a308ec4fa7c22ae4dc175c87d5d35a52395c0aade8a4557048bfd4454ff44ffc8240d32f2ec57217f55d076693f3995dded656427f692ec77383288592de394e18ee4c1839658172188f155c5b00a292318fc1be37b83c9cae08d9c01a8ec330ab37f8bf77f558af5d593672d960f7bcf0b0be7b2d6788ada6fb22d6c908e56013dab63436ab35b61bea40726e9c9548a3586c11a340f9d9d6d3fdfae786fb0a1b0bb2c7e45219eb2f5ef43c1f0273dba61750c6be480989ee8a22d1e35ffc1aeea888b43069393e37f688a5cda246d623680b33bac0a10406ece1e14a215b2ff76a6166b6423ed89db3e6fc893ded03b37758c672da8774075af129c4c90621f629f8446ba76d6744adaad6cbc31be7040f9bfca6bde8d8c73b97275e77071640457151ac6faf3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      这里有东西被加密了，需要输入密码查看哦。
    
    </summary>
    
    
      <category term="secret" scheme="https://mrzhangboss.github.io/tags/secret/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Alibaba浅探</title>
    <link href="https://mrzhangboss.github.io/2021/03/16/java/springcloud/springcloudalibaba%E6%B5%85%E6%8E%A2/"/>
    <id>https://mrzhangboss.github.io/2021/03/16/java/springcloud/springcloudalibaba浅探/</id>
    <published>2021-03-16T12:05:53.000Z</published>
    <updated>2021-03-16T12:43:29.814Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>花了半天时间把Spring Cloud Alibaba 的<code>Nacos</code> 、 <code>Sentinel</code> 和 <code>Seata</code>简单的使用了一下，下面是我的一些看法</p></blockquote><h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h2><p>Nacos 干了三件事，第一个就是把服务注册的活给揽过来了，第二个就是把配置中心的活给揽过来了，而且由于他是要监控各个服务的心跳的，<br>所以他顺便把配置同步这个活也给抢过来了</p><p>Nacos做了很多事，美中不足的地方是，Nacos更希望你在网页上进行配置（当然可以通过url），比如说Spring Cloud Config 是希望你更新源代码然后再来将配置给更新 掉</p><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p>Sentinel是一个流量控制的中间件，作用和Hystrix差不多，不过，相比于Hystrix，Sentinel提供了一个web界面来<br>帮助你定制限流规则，主要是保护后端</p><p>这些规则其实也很简单，多尝试一下就好了，我其实很好奇，Sentinel在其中做的工作是什么，他是如何保证异常流量不<br>把自己给打爆的，当然负载均衡可以一定量的缓解这些</p><h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h2><p>这个号称实现了分布式事务的软件，我没搭起来，尝试几个小时无果后，而且网上的资料也异常的少，甚至他们官方写的demo我也跑不起来<br>我看他们的start虽然多，但是issue也多，每个版本都有坑</p><p>我也尝试去搜索有没有大公司尝试使用这个分布式事务，很遗憾没找到，首先限死了用MySQL，而且非常恶心的事每个数据库上面都得创建一个<code>undo</code>表</p><p>我可以理解你在一个数据库上记录这些东西，但是我没法理解你要所有的数据库都建这么个表</p><p>而且非常坑的事，官网SSL证书当天正好到期，在我看了引用了这么个分布式事务，第一肯定涉及到了很多锁，我看原理介绍上<br>也说了开始事务前会上锁，对于现在通用解决方案都是消息队列来处理这个东西的,引入分布式锁并发不高，而且万一锁表凉凉了</p><p>所以我就去找有没有什么大公司实践过了，可是很遗憾好像没有，也没没看到有什么性能测试，而且部署半天报各种问题，每个版本都不一样，怕是个PPT项目<br>还是改天有空的时候在研究研究</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实Spring Cloud Alibaba比较重要的一个部分就是将Dubbo集合到了Spring Cloud，所以我接下来的时间得好好看看Dubbo了，目前Spring Cloud这些组件只能说都上手摸了一会<br>要想真正的成长还得去实际项目考验</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;花了半天时间把Spring Cloud Alibaba 的&lt;code&gt;Nacos&lt;/code&gt; 、 &lt;code&gt;Sentinel&lt;/code&gt; 和 &lt;code&gt;Seata&lt;/code&gt;简单的使用了一下，下面是我的一些看法&lt;/p&gt;
&lt;/blockqu
      
    
    </summary>
    
      <category term="Java" scheme="https://mrzhangboss.github.io/categories/Java/"/>
    
    
      <category term="SpringCloud SpringCloudAlibaba" scheme="https://mrzhangboss.github.io/tags/SpringCloud-SpringCloudAlibaba/"/>
    
  </entry>
  
</feed>
