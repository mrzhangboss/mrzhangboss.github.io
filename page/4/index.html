
 <!DOCTYPE HTML>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
  
    <title>lunge博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="张伦">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="lunge博客">
<meta property="og:url" content="https://mrzhangboss.github.io/page/4/index.html">
<meta property="og:site_name" content="lunge博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lunge博客">
<meta name="twitter:creator" content="@mrzhangboss">

    
    <link rel="alternative" href="/atom.xml" title="lunge博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/wx.jpeg">
    
    
    <link rel="apple-touch-icon" href="/img/wx.jpeg">
    <link rel="apple-touch-icon-precomposed" href="/img/wx.jpeg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/wx.jpeg" alt="lunge博客" title="lunge博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="lunge博客">lunge博客</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="搜索" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/10/08/PostgreSQL的自增键/" title="PostgreSQL的自增键" itemprop="url">PostgreSQL的自增键</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="张伦" target="_blank" itemprop="author">张伦</a>
		
  <p class="article-time">
    <time datetime="2017-10-07T16:00:00.000Z" itemprop="datePublished"> 发表于 2017-10-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>平常在Django项目中大量使用自增这个键，平常都是使用ORM，很少去了解这个东西在数据库中具体使用，最近遇到要备份和复原数据的事情，趁着这次好好探索一下这个自增键的使用</p>
</blockquote>
<p><code>Django</code>里面大部分都是将其作为<code>Int</code>自增主键来使用，第一个不需要维护一个唯一值，第二个使用<code>Int</code>作为主键的话，搜索和外键关联速度比较快。</p>
<p>我们这次从原生<code>SQL</code>出发，探索一下这个自增主键在数据库中的具体使用</p>
<h3 id="新建数据库"><a href="#新建数据库" class="headerlink" title="新建数据库"></a>新建数据库</h3><p>我们先新建一个数据库</p>
<pre><code>create table inc(
id serial not null,
name text
);
</code></pre><p>在<code>PG</code>里面简单的使用<code>serial</code>关键字就会生成一个自增键，默认会在数据库新建一个索引表，例如上面就会新建一个<code>inc_id_seq</code>的索引表，这个字段类型为<code>int</code>，如果数据库很大，我们可以使用<code>BIGSERIAL</code>键申请一个<code>bigint</code>类型的字段</p>
<p>我们可以看一下这个索引表里面有什么</p>
<pre><code>         Sequence &quot;public.inc_id_seq&quot;
    Column     |  Type   |        Value        
---------------+---------+---------------------
 sequence_name | name    | inc_id_seq
 last_value    | bigint  | 1
 start_value   | bigint  | 1
 increment_by  | bigint  | 1
 max_value     | bigint  | 9223372036854775807
 min_value     | bigint  | 1
 cache_value   | bigint  | 1
 log_cnt       | bigint  | 30
 is_cycled     | boolean | f
 is_called     | boolean | t
</code></pre><p>我们可以这个索引表其实就是维护了一个参数，通过字段我们可以知道，这是一个自增为1的键，下一个值为2，目前没有插入一个值</p>
<h3 id="增删查减"><a href="#增删查减" class="headerlink" title="增删查减"></a>增删查减</h3><p>我们通过一些基本操作来看看这个自增键的作用</p>
<ul>
<li>首先是插入</li>
</ul>
<pre><code>insert into inc (name) values (&apos;1&apos;),(&apos;2&apos;), (&apos;3&apos;);
</code></pre><p>我们插入三个值，我们再查看索引表，发现<code>last_value</code>变成了3</p>
<p>这个是没有指定<code>id</code>的值插入，我们试试显式声明插入</p>
<pre><code>insert into inc  values (1, &apos;1&apos;),(2, &apos;2&apos;), (3, &apos;3&apos;), (4, &apos;4&apos;);
</code></pre><p>我们惊奇的发现，在我们显式声明自增键的值的时候，索引表并没有变化，<code>last_value</code>还是3,<strong>这说明只有在不声明自增键，让数据库自己新建的时候，索引表才会更新</strong></p>
<p><strong>我们可以把自增键看做一个默认值，当没有给自增键赋值的时候，这个自增键会从这个键的索引表中得到下一次自增的值</strong></p>
<p>所以我们再尝试使用不声明自增键值的方法插入一个新值</p>
<pre><code>insert into inc (name) values (&apos;4&apos;)
</code></pre><p>我们发现索引表中<code>last_value</code>变成了4</p>
<h3 id="主键自增"><a href="#主键自增" class="headerlink" title="主键自增"></a>主键自增</h3><p>由于我们在<code>Django</code>里面使用自增，一般都是将其声明为主键，设为唯一值，所以如果我们将声明表的结构变成</p>
<pre><code>    create table inc(
id serial not null PRIMARY KEY,
name text
    );
</code></pre><p>上面的情况就不可能发生了，因为我们把自增键声明为主键，不过有意思的事就是如果你像上面一样指定了一个自增主键值为4，然后不指定再插入4，你会发现第一次会报主键不允许重复的错误，第二次则会成功插入，而且索引表的<code>last_value</code>变成了5</p>
<p>看来并不是每次成功的时候才会更新<code>last_value</code>值，只要让系统自己去申请自增值就会更新索引表，我尝试了对表的增删查改，发现只有<code>insert</code>并且申请自增值的时候才会更新索引表，而且这个索引表之后增加，不会减少，所以有时候你删掉最大的值，自增键默认又从最后一次开始更新</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在对单个数据表备份还原的时候，由于简单的使用了<code>COPY</code>命令进行备份还原，通过上面的探索我们发现如果涉及到自增主键的导入导出，在新表导入旧数据是不会出错的，但是由于我们没有考虑自增键的影响（我们导入自增键是显示赋值），在后面插入数据的时候有可能会报主键重复的错误</p>
<p>为了避免以后插入入数据出现这样的错误，我们有两种措施</p>
<ol>
<li>使用<code>COPY</code>命令导入导出时候不获取自增键值</li>
<li>在<code>COPY</code>导入新表后自己更新索引表</li>
</ol>
<p>第一种的话<code>SQL</code>比较繁琐（必须写出表所有字段值），推荐使用第二种</p>
<p>我们可以简单的使用</p>
<pre><code>SELECT MAX(id) FROM your_table;
</code></pre><p>先获取自增键最大值，然后更新索引值(999为上面你获取的最大值）</p>
<pre><code>SELECT setval(&apos;your_table_id_seq&apos;, 999, false);
</code></pre><p>当然我们可以将这条语句合正一句话</p>
<pre><code>SELECT setval(&apos;your_table_id_seq&apos;, COALESCE((SELECT MAX(id)+1 FROM your_table), 1), false);
</code></pre><p>这样我们就可以开心的完成单表导入导出了</p>
<p>ps：<br>在使用<code>COPY</code>命令时必须是superuser才能从文件中读取和导入数据，最简单的方法是用superuser账号加权使用<code>alter user xxx superuser</code>，待倒完数据后再降权<code>alter user xxx nosuperuser</code></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/software/">software</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/10/08/PostgreSQL的自增键/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/10/08/PostgreSQL的自增键/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/10/07/my_college_mistakes/" title="大学的错觉" itemprop="url">大学的错觉</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="张伦" target="_blank" itemprop="author">张伦</a>
		
  <p class="article-time">
    <time datetime="2017-10-06T16:00:00.000Z" itemprop="datePublished"> 发表于 2017-10-07</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>其实这篇文章很早就像写了，但是自己也一直没有明白自己想写什么，直到最近自己慢慢才有一点思路</p>
</blockquote>
<p>   这篇文章并不想高谈阔论，只是自己的一些碎碎念，把自己对人生的一些看法的小总结。你可以把它当做一篇小说来看，我也想把它当做小说来写。</p>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>中秋回家，同自己表妹聊天，她突然问了一句,大学哥哥没有谈一个女朋友，接着说道没有恋爱的大学是不完整的，我楞了一愣，一本正经的对她说道，大学其实就是培养自己一个完整人格的过程，在这个过程中我们学习并且养成自己一个完整独立认知。</p>
<p>回去之后我仔细想想，我好像并没有回答表妹的问题，但是我自己也陷入了深思，大学这几年到底对我干了什么。</p>
<h2 id="错觉"><a href="#错觉" class="headerlink" title="错觉"></a>错觉</h2><p>先不说大学对我做了什么，我仔细想了想我自己对自己定位。</p>
<h3 id="你觉得你很努力"><a href="#你觉得你很努力" class="headerlink" title="你觉得你很努力?"></a>你觉得你很努力?</h3><p>我一直觉得自己在大学还是很努力的，我没有沉迷游戏超过两天，我没有放弃学习新知识，在大学图书馆借了几百本书，可能比全班人加起来都多，大一到大三我经常去图书馆读书，尤其是大三，有时候会在图书馆读一天书</p>
<p><strong>但是上面的上面全部我自己的错觉，我虽然不沉迷游戏但是经常会被游戏分心，我虽然读过很多书但是我一直是读那些别人认为是必读的书，而且我读过的书大部分都没有转换成为我真正的源泉</strong></p>
<p>我就像一个饥渴的行者，在大河面前用手拼命的往口里塞水，我的确看了很多的书，但是这么多书就像流水一样，全部都流走了;这些知识对于我来说只是解渴之物，当我非常饥渴的时候，我会拼命的想得到它，但是当我满足的时候，这些东西就像泥土一样对我一文不值</p>
<p>所以这就可以解释为什么我每次借书的时候都是兴高采烈，但是当借回来时候往往翻了几页，然后就束之高阁，然后循环往复</p>
<h3 id="你觉得你懂很多"><a href="#你觉得你懂很多" class="headerlink" title="你觉得你懂很多?"></a>你觉得你懂很多?</h3><p>没有出去之前，我在大学社团里面干过不少项目，所以我有时候觉得自己技术很牛逼，我是大神级别的人。我懂很多别人不知道的知识，我用过很多框架，我知道怎么搭集群，我知道什么是机器学习，什么是分布式，什么是代码规范。</p>
<p>然而出去之后才发现这都是错觉，你做过很多项目，你经历过百万规模的并发吗，你了解很多框架，随便挑一个框架出来，你能说出它的优点和不足吗，你看过源代码吗，你知道如何保证上千集群的容错率，你知道什么是大规模机器学习吗</p>
<p>挑出任何一个你会发现自己一直处在皮毛阶段，有时候你会用你还年轻但是学习能力强来掩饰你的不足，但是这只是你的错觉吧，不懂就是不懂。</p>
<h3 id="你觉得你不需要明确方向"><a href="#你觉得你不需要明确方向" class="headerlink" title="你觉得你不需要明确方向?"></a>你觉得你不需要明确方向?</h3><p>有段时间我一直很困惑自己未来发展方向，我搞过UI，搞过前端、后端，搞过机器学习、数据分析，搞过分布式、爬虫。编程语言更是多，C、C#、Python、Java、C++，node，JS。我对我自己的定位一直很模糊，我不知道我未来到底想干什么，我很羡慕那些从小就明确目标的人。</p>
<p>我一直为此苦恼，我也看过很多人的书籍、博客，我也看到过很多人写的相同的文章，在很长一段时间我都认为它是正确的，它告诉我你不需要明确你的职业规划，它给了很多有名的人例子，奥巴马、马云、马化腾、李开复他们在大学都不知道自己要干什么。在很长一段时间我都觉得大学就是应该多学东西，把东西学杂。</p>
<p>但是我仔细想想，这个也是<strong>错觉</strong>。</p>
<p>我从大二就开始有转行的念头，当时我是web后端开发，我当时觉得有没有方向无所谓，只要你多学就行，就这样陆陆续续混杂看了一年多书，直到七八个月前，我才开始反思。</p>
<p>我开始明确我的目标，把它当做我要干一辈子的方向去搞，我开始扣书，像一个干涸的大地一样汲取天空飘下的雨滴，我这时候发现知识是那么的宝贵，自己是多么的“native”；从一窍不通到入门到小小成就只花了短短几个月的时间，完成了一年多都完成不了的入门。</p>
<p>当然我最终没有选择这个方向，但是这个过程我从来没有后悔过，而且在这个学习过程中，它帮助我更加了解我自己，而且节省了我选择的时间。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>好像我的大学一直全部都是由错误组成的，但是这些错误真的对我来说毫无作用吗。其实未必，当我学完第一门编程语言C的时候，所以的“错误”都在默默的发挥的作用，我用静态语言的辩证思想学Python，我用动态语言的思想反过来学习Java，好像全部的“错误”全部融合成为一个圈，</p>
<p><strong>我们好像一直在害怕自己出错，其实慢慢的发现那些没有错误的人生不是完整的。</strong></p>
<p>小时候很羡慕那些一直走在正确的道路上的人，也有时候会幻想成为他们一样的人。没错那样的人生固然完美，但是我更喜欢一直跌跌撞撞的我，或许我经常走在错误的道路上，但是我享受了沿途的风景，不论最终结果如何，人生的意义还是沿途的风景吧!</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/summary/">summary</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/10/07/my_college_mistakes/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/10/07/my_college_mistakes/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/08/09/vip_ctrip_competitions_summary/" title="唯品会预测和携程房屋预测总结" itemprop="url">唯品会预测和携程房屋预测总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="张伦" target="_blank" itemprop="author">张伦</a>
		
  <p class="article-time">
    <time datetime="2017-08-09T11:21:40.000Z" itemprop="datePublished"> 发表于 2017-08-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>最近打了两个比赛，一直忙着工作和打比赛，没有时间总结，今天抽空好好总结一番</p>
</blockquote>
<p>先说一下比赛结果吧，队名全为<code>OfferGo</code><a href="http://www.datafountain.cn/#/competitions/260/ranking/a/0" target="_blank" rel="external">唯品会购买预测</a>第五名，<a href="https://www.kesci.com/apps/home/#!/competition/597172316a1cd9104c2df248/leaderboard/0" target="_blank" rel="external">携程房屋预测复赛</a>第六名,两个比赛打的都不算太好,只能算勉强及格,虽然离大神的距离还有十万八千米，不过总算可以称的上入了门，现在来总结一下我入门的经验吧。</p>
<h2 id="观察数据"><a href="#观察数据" class="headerlink" title="观察数据"></a>观察数据</h2><blockquote>
<p>我参加过很多群,发现很多新手缺乏观察数据的能力,他们每次进入一个群总是嚷嚷这让大神发<code>baseline</code></p>
</blockquote>
<p>这一点对于新手来说很不利的，比赛考的就是你对数据的掌握能力,你对数据把握的越好，你的比赛成绩就越好，要真正掌握数据就要从观察数据入手</p>
<hr>
<p>在我看来观察数据主要从四个方面来，我总结为<code>望闻问切</code></p>
<h3 id="望"><a href="#望" class="headerlink" title="望"></a>望</h3><p>观察数据缺失值，缺失值对数据影响很大，有时候我们能够从缺失值里面了解很多信息,而且对于缺失值，后期我们对不同的缺失值要采取不同的手段，比如补全、统计占比、丢弃等等。</p>
<p>对于缺失值我一般从两个方面来观察</p>
<ul>
<li>全局观察</li>
<li><ul>
<li>一般采用<code>datafram.info(null_counts=True, verbose=True)</code>方法来观察全局数据缺失情况</li>
</ul>
</li>
<li>局部观察</li>
<li><ul>
<li>一般采用<code>series.isnull().count()</code>和<code>series.loc[series.notnull()]</code>观察单一列表缺失情况</li>
</ul>
</li>
</ul>
<p>这个阶段我们主要从大的方向远远的<code>望</code>一下数据，主要建立对数据的全局观。</p>
<h3 id="闻"><a href="#闻" class="headerlink" title="闻"></a>闻</h3><blockquote>
<p>对于数据来说，一般分为三种，一种为数值型数据（整数、浮点数、时间等），一种为字符型，最后一种为图像型，三种类型数据处理难度依次增强</p>
</blockquote>
<p>对于大多数比赛都是设计前两种数据，第三种只有牵扯到图像处理才能遇到。对于前两种数据，我们在闻的阶段，主要是探查数据分布情况，了解数据分布情况，我们才能对症下药。</p>
<p>了解数据分布情况有两种方法</p>
<ol>
<li>图像观察</li>
<li>数学统计观察</li>
</ol>
<p>图像观察主要使用<code>Pandas</code>的<code>Matplotlib</code>绘图接口，或者使用<code>seaborn</code>（一个友好的封装了<code>Matplotlib</code>的包），一般我们可以从直方图、饼图、频率图方向来观察数据</p>
<p>数学统计我们主要采用<code>Pandas</code>的<code>describe</code>方法，对于数值型数据，主要从平均值（<code>mean</code>）、中位数（<code>50%</code>）、标准差（<code>std</code>）、最大（<code>max</code>）、最小（<code>min</code>）、非空总数（<code>count</code>）来探测数据，对于字符型我们主要从最频繁的值（<code>top</code>）、最频繁的值的个数（<code>freq</code>），非空总数（<code>count</code>）、不相同的值（<code>unique</code>）。</p>
<p>通过上面两种方法，我们能够从数据分布的角度大致勾画出数据的轮廓。</p>
<h3 id="问"><a href="#问" class="headerlink" title="问"></a>问</h3><blockquote>
<p>比赛的目的就是找到最优解，而最优解的跟相关特征紧密联系的，你的特征对结果影响越大，你就要审<code>问</code>这个特征</p>
</blockquote>
<p>举个例子，我们要预测三组数据</p>
<ul>
<li>1 1.8  2</li>
<li>2 3.5  4</li>
<li>3  5.4  16</li>
</ul>
<p>第一行为我们要训练的值，我们发现第二行的数据是第一行的1.8倍，而第三行只是2的次方，对于这两个特征来说，第二个特征就是最好的特征，我们只要建立一个映射，准确率能接近100%，而第三个特征对预测结果毫无联系，这个特征不但对结果没有作用，而且有时候会起到反作用</p>
<p>当然在这里我们举这么一个例子在实际中不可能遇到，我们遇到是更多数据，而数据之间的联系并不是这么简单的线性关系，但是线性关系有的时候能让我察觉到特征与预测值的关联，毕竟如果特征值是随机值那么与预测值之间的相关性是非常低的。</p>
<p>在<code>Python</code>里面探测线性关系最简单的方法是调用特征值和预测值的相关性系数（<code>corr</code>），我们可以简单的使用<code>df[[&#39;feature&#39;, &#39;target&#39;]].corr()</code>就可以得到线性相关系数，这个数的绝对值越接近1，相关性越大，一般来说相关性越大和越好对结果都不好，最好的特征相关性处于中间位置。</p>
<p>相关性低我们可以理解，为什么相关性高反而不好呢，因为数据比赛里面给我们的数据大部分都是不平衡的数据，正负样本失衡，一般相关性很高的值一般为分类同预测值相同，比如一个二分类问题，预测值为0和1，给的样本正负比为1000:1，那么如果有一个特征全为0或者其他，那么他与预测值的相关性会达到90%以上，然而这个值是毫无作用的。</p>
<p>所以我们通过简单的相关系数并不能很好的观察特征真正相关性，一般我们要辅助图像法和统计法。</p>
<p>图像法就是通过将特征值分布与预测值相关性图表画在同一个图表里，具体可以参考<a href="https://www.kaggle.com/benhamner/d/uciml/iris/python-data-visualizations" target="_blank" rel="external">可视化特征</a></p>
<p>统计法类似图标，使用统计方法观察，特征值与预测值的相关性，一般使用<code>groupby</code>方法对两个特征进行统计就可以进行简单的观察</p>
<p><code>问</code>只是一个简单的手段，一般我们在大量添加特征的时候，为了节省模型训练时间，在将特征放入管道之前进行一个简单的过滤删除的工作，真正重要的步骤在<code>切</code>这个方面</p>
<h3 id="切"><a href="#切" class="headerlink" title="切"></a>切</h3><blockquote>
<p><code>切</code>这个步骤放在最后是因为，这个步骤也是我们一趟循环下来的最后一步</p>
</blockquote>
<p>数据比赛中前期大家最喜欢用的模型是树模型，比如随机森林、<code>Xgboost</code>，<code>LightBoost</code>等，这些模型属于弱学习器组合模型，我们最后可以从训练结果得到每个特征在模型占的比重</p>
<p>对于这个比重，是非常重要的，他代表了每个特征对应在模型中占的权重，也可以理解特征与结果的相关性</p>
<p>对于相关性很强的不同的特征，我们可以将他们组合，有时候这种强强组合生成出来的特征会比原来母特征相关性更强，当然组合的方法有千种万种，如何验证他们有效就要从头开始对数据进行<code>望闻问切</code>了</p>
<h4 id="总结：-数据比赛就如同问诊，我们不断对特征进行望闻问切，对于高手来说他们能很快的从原始特征中挑选出病根，对症下药，而新手的话，一阵摸瞎，经常会碰到在比赛中期做出一个很好的结果，接下来很长一段时间都没有进步的情况。掌握科学有效的挑选特征方法需要一个“医者心”，必须学会对特征“负责”，要学会望闻问切。"><a href="#总结：-数据比赛就如同问诊，我们不断对特征进行望闻问切，对于高手来说他们能很快的从原始特征中挑选出病根，对症下药，而新手的话，一阵摸瞎，经常会碰到在比赛中期做出一个很好的结果，接下来很长一段时间都没有进步的情况。掌握科学有效的挑选特征方法需要一个“医者心”，必须学会对特征“负责”，要学会望闻问切。" class="headerlink" title="总结： 数据比赛就如同问诊，我们不断对特征进行望闻问切，对于高手来说他们能很快的从原始特征中挑选出病根，对症下药，而新手的话，一阵摸瞎，经常会碰到在比赛中期做出一个很好的结果，接下来很长一段时间都没有进步的情况。掌握科学有效的挑选特征方法需要一个“医者心”，必须学会对特征“负责”，要学会望闻问切。"></a>总结： 数据比赛就如同问诊，我们不断对特征进行<code>望闻问切</code>，对于高手来说他们能很快的从原始特征中挑选出<code>病根</code>，对症下药，而新手的话，一阵摸瞎，经常会碰到在比赛中期做出一个很好的结果，接下来很长一段时间都没有进步的情况。掌握科学有效的挑选特征方法需要一个“医者心”，必须学会对特征“负责”，要学会<code>望闻问切</code>。</h4><h2 id="并行化算法"><a href="#并行化算法" class="headerlink" title="并行化算法"></a>并行化算法</h2><blockquote>
<p>由于<code>Python</code>本身对多核利用不好，如何利用多核加快特征生成对于比赛来说意义重大</p>
</blockquote>
<p>就拿我来举例子，我每天下班打比赛的时间不超过8个小时，前期算法没有并行化的时候，走一遍管道要四个小时，这意味着我一天只能跑两次，而进行并行化优化以后，我跑一遍四线程全开（笔记本双核四线程）只要十分钟就能跑完，每次生成新特征只有10分钟就能拿到特征相关性数据，来验证特征的好坏。</p>
<p>下面我从三个方面来谈谈怎么实现并行话算法</p>
<h3 id="1-使用系统自带函数，拒绝for循环"><a href="#1-使用系统自带函数，拒绝for循环" class="headerlink" title="1 . 使用系统自带函数，拒绝for循环"></a>1 . 使用系统自带函数，拒绝<code>for</code>循环</h3><p>举个例子，作为新手，实现对两个个特征求平均，一般采用<code>for</code>循环将每一行两个特征值加起来然后除以2，假如有1000万行，每行加法和除法运算花0.001ms，那1000万也要10秒钟，只是进行一个最简单的求平均，你就花掉10秒钟，上百个特征你得运行几天</p>
<p>学过矩阵的都知道，矩阵就是一种高效的并行化结构，它将集合统一进行计算，可能一个大矩阵运算要比单一计算要慢，但是单一计算要1000万次的话，大矩阵运算只需要两次就够了，这个效率比就出来了</p>
<p>而<code>Python</code>由于是一门解释性语言，比其他静态语音速度要慢许多，你一方面使用<code>for</code>循环加大运算次数，一方面执行一次时间长，这相重叠加你的算法会跑的比蜗牛还慢</p>
<p>所以我们避免使用我们写的函数，尽量使用库系统函数，因为库系统函数底层是使用<code>C</code>或<code>C++</code>实现的，而且他们在底层进行使用矩阵话运算代替单一浮点计算，我们使用库的函数（比如<code>mean</code>，<code>groupby</code>等）一方面能底层能使用C加快速度，一方面使用矩阵运算加快速度，两个叠加你的算法跑的比飞机还快。</p>
<h3 id="2-使用多进程，充分发挥使用多核性能"><a href="#2-使用多进程，充分发挥使用多核性能" class="headerlink" title="2 . 使用多进程，充分发挥使用多核性能"></a>2 . 使用多进程，充分发挥使用多核性能</h3><p>由于<code>Python</code>的<code>GIL</code>锁，使得<code>Python</code>无法利用多核进行计算，所以我们只能使用多个进程来充分利用多核</p>
<p>实现多进程有两个要点（具体可以参考我携程比赛代码 <a href="https://www.github.com/mrzhangboss" target="_blank" rel="external">Github地址</a>)</p>
<ul>
<li>特征提取模块化</li>
<li>进程池的搭建和维护</li>
</ul>
<p>我在携程比赛中的<code>mult_run.ipynb</code>中搭建了一个进程池，通过第三方调度和监控进程内存CPU等信息，达到充分“榨干”每个核的功效</p>
<h3 id="3-压缩数据，让矩阵运算更快"><a href="#3-压缩数据，让矩阵运算更快" class="headerlink" title="3 . 压缩数据，让矩阵运算更快"></a>3 . 压缩数据，让矩阵运算更快</h3><p>由于在对特征进行提取过程中，<code>Python</code>会自动将低位制值转换成高位制值，比如<code>float16</code>在进行一次<code>groupby</code>之后就会转换成<code>float64</code>，由于在矩阵运算时候，高进制值会占更多内存和运行时间，所以为了加快算法运行，我们要将其压缩，一方面节省内存，一方面能够让算法运行的更快</p>
<p>在携程的比赛中，原始数据有一个G，我将其压缩之后只占用300M内存空间，这为我后面在一台12G内存的笔记本实现并行化算法提供了巨大帮助，当然我每次在生成新特征的时候也会进行压缩，具体可以参考我携程的<code>utils.py</code>文件</p>
<h3 id="总结：-这两次比赛，我从菜鸟出发慢慢的从一个程序员变成了数据挖掘机，在模块化和并行化方面，我觉得我的进步不错，但是在数据特征挖掘方面我与大神之间的差距还是巨大的，这也是我止步于前五的主要原因，接下来我要加强对数据方向的锻炼，希望能够在工作和比赛之中得到更好的进步"><a href="#总结：-这两次比赛，我从菜鸟出发慢慢的从一个程序员变成了数据挖掘机，在模块化和并行化方面，我觉得我的进步不错，但是在数据特征挖掘方面我与大神之间的差距还是巨大的，这也是我止步于前五的主要原因，接下来我要加强对数据方向的锻炼，希望能够在工作和比赛之中得到更好的进步" class="headerlink" title="总结： 这两次比赛，我从菜鸟出发慢慢的从一个程序员变成了数据挖掘机，在模块化和并行化方面，我觉得我的进步不错，但是在数据特征挖掘方面我与大神之间的差距还是巨大的，这也是我止步于前五的主要原因，接下来我要加强对数据方向的锻炼，希望能够在工作和比赛之中得到更好的进步"></a>总结： 这两次比赛，我从菜鸟出发慢慢的从一个程序员变成了数据挖掘机，在模块化和并行化方面，我觉得我的进步不错，但是在数据特征挖掘方面我与大神之间的差距还是巨大的，这也是我止步于前五的主要原因，接下来我要加强对数据方向的锻炼，希望能够在工作和比赛之中得到更好的进步</h3><h4 id="在最下面贴一下我的携程比赛代码（基于Notebook）"><a href="#在最下面贴一下我的携程比赛代码（基于Notebook）" class="headerlink" title="在最下面贴一下我的携程比赛代码（基于Notebook）"></a>在最下面贴一下我的携程比赛代码（基于Notebook）</h4><p><a href="https://www.github.com/mrzhangboss/ctrip_room_predict" target="_blank" rel="external">https://www.github.com/mrzhangboss/ctrip_room_predict</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/competition/">competition</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/08/09/vip_ctrip_competitions_summary/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/08/09/vip_ctrip_competitions_summary/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/13/大航杯“智造扬中”电力AI大赛参赛经验/" title="如何搭建自动生成上万特征的管道" itemprop="url">如何搭建自动生成上万特征的管道</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="张伦" target="_blank" itemprop="author">张伦</a>
		
  <p class="article-time">
    <time datetime="2017-06-13T10:56:31.000Z" itemprop="datePublished"> 发表于 2017-06-13</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>基于:大航杯“智造扬中”电力AI大赛参赛经验</p>
<p><img src="/images/electric_power_ai.jpg" alt="大航杯AI大赛"></p>
<p>赛题背景</p>
<blockquote>
<p> 主办方为大航集团提供21个月江苏省杨中市1454家企业日用电量,来估计下一个月日总用电量</p>
</blockquote>
<p>从给的数据分析,这次给的数据只有历史企业日用电量,用来估计日总用电量,是一个典型的时域分析问题</p>
<p>但是这同我们以往的时序问题不一样,向往常时序问题预测的是每个企业的未来每日的用电量,而这个比赛却是求全部企业的总数.</p>
<p>由于我报名比赛时候比较晚,比赛已经接近尾声,比赛5月18号开始,6月8号中午切换数据,13号截止,我6月8号晚上下载数据,由于我以前已经做了几个类似的比赛,但是一直没有系统的做一个,抱着锻炼的自己的态度,决定系统做一次,权当练手.</p>
<p>首先分析一下提交的结果,预测一个月的日总用电量,总共为31个数据,给的历史数据只有21个月的,按月的比例来看,只有21个值去训练值去预测一个值,根据往常的比赛经验来看,这种比赛适合使用规则方法来做,然而我剩下的验证机会不多了,只能用模型,但是过拟合的危险非常大,如果不能找到一个好的方法克服过拟合,复赛都进不去.</p>
<p>当然最后还是没有找到一个很好的办法,止步于复赛,不过这次比赛让我学到很多,主要通过这次比赛自己琢磨出来自己如何搭建基于<code>IPython Notebook</code>的管道结构,这个管道帮我自动生成上万特征.</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><blockquote>
<p>什么是管道,在数据挖掘比赛中很多大神都着重讲了一定要搭建一个自动化的架构,我们暂且称他为”管道”,这个”管道”我们要能够把数据倒进去,结果倒出来.</p>
</blockquote>
<p>这个管道用专业的术语来看要有以下几个功能</p>
<ul>
<li>能够自由添加<code>Feture</code></li>
<li>能够自动评判得到添加的<code>Feture</code>的效果</li>
<li>管道能够自己选择合适的参数训练模型</li>
<li>能够输出结果</li>
</ul>
<p>其实简单来说,我们要做的是一个能够非常方便的扩展的脚手架,我们不可以第一次就把所以的特征全部找出来,所以我们要搭建一个能够实时添加<code>Feture</code>的框架.</p>
<p>其实很早以前就看过类似文章,也有很多人推荐<a href="https://github.com/ChenglongChen/Kaggle_HomeDepot" target="_blank" rel="external">大神开源的一个脚手架</a>,然而找到的大多是用<code>python</code>实现</p>
<p>我因为一开始就是使用<code>Notebook</code>进行数据挖掘,主要<code>Notebook</code>能够提供一个实时的反馈,而纯<code>python</code>,对于复杂多变的数据来说,显得非常笨重,你经常有个好想法想验证一下,又得重新跑一遍,尤其是对于我的机器配置来说,重新跑一边的时间都够我喝杯茶了.而且<code>notebook</code>有个特点,可视化特别方便,有时候从数据上看不到,可以画个图表</p>
<p>好了,夸了这么久,现在就来仔细讲讲脚手架如何搭建.</p>
<p>我们先回到赛题,第一步审题,当时我看到日平均两个字,直接把日字省略,看成平均用电量,结果白白浪费了两个验证机会…..</p>
<p>审完了题我们来看我们要提交的数据,换数据后要预测十月日用电总量.我们来看看给我们数据,只有一份数据,表头如下</p>
<pre><code>record_date,user_id,power_consumption
2015/1/1,1,1135
2015/1/2,1,570
2015/1/3,1,3418
2015/1/4,1,3968
2015/1/5,1,3986
</code></pre><p>解释一下字段,<code>record_date</code>–日期,<code>user_id</code>–企业id, <code>power_consumption</code>–日用电量<br>非常简单,就这么简单单单的数据,我现在要教大家怎么从这么简单的数据上抽取6000维度的</p>
<p>我把代码已经推到<code>Github</code>上了(由于数据比较少,我把数据也推上去了,方便大家本地跑跑,看完如果对你有帮助的话,请不要吝啬你的star哦),我就对照我的代码解释如何搭建一个可以跑出上万维度的脚手架</p>
<h2 id="数据划分-split-samples-ipynb"><a href="#数据划分-split-samples-ipynb" class="headerlink" title="数据划分(split_samples.ipynb)"></a>数据划分(<code>split_samples.ipynb</code>)</h2><p>首先要搭建本地预测集,也就是线下样本(这个很重要,有时候线下的结果很大程度对应你线上的结果)</p>
<p>给的数据要我们从前面21个月预测下一个月的日总用电量,我们很容易就能想到,那我们用前面20个月预测第21个月来做线下测试,但是这样我们就只有30个训练样本,要来预测30个,99.999%过拟合啊,首先我们要扩大样本,我们采用滑动移窗的方法把预测的样本按照月份推移,也就是分别预测9月8月7月等等</p>
<p>这种方法在实现<code>Notebook</code>有几个难点,首先你划分了预测集,那么就也要划分训练集,就相当于把一份数据切分成好几份,切分完之后有个问题,你必须要隔离每个部分</p>
<p>举个例子,我们把训练集划分成为2份,1月到7月预测8月,2月到8月预测9月,训练1-7月数据集的时候,我们不能让这个训练集接触到2月到8月的数据,因为8月对于前一个训练集来说是未知的,<br>如果我们让第一个训练集接触倒第二个训练集我们称为信息泄露,很影响线上的结果</p>
<p>我们知道这个问题之后,我们就要用巧妙的方法来解决,首先我们要考虑我们代码的复杂度,以前我的解决训练集隔离的方法采用的是循环法,使用一个列表存贮所以训练集,然后使用<code>for</code>循环分别传参到函数里面,这个方法能解决隔离训练集,但是有几个问题</p>
<p>在单个<code>ipy</code>文件中训练所以的样本,在测试的时候跑起来太慢,而且要把数据全部加载在内存里面,这次数据量还算小,但是对于某些小内存的电脑来说,这种方法时不时就得报<code>Memory Error</code>,而且感觉调试起来特别麻烦,所以一直在寻找更好的解决方案.</p>
<p>这次想到了一种巧妙的方法,虽然有点取巧但是效果我很满意.</p>
<p>我们先看到<code>split_samples.ipynb</code>文件,首先我把数据划分为9个样本,一个预测样本.分别放入不同文件夹进行物理隔离.但是名字相同.</p>
<p>再其次我让<code>ipy</code>能够获取参数,这样我通过外部参数就能更换数据集,平常添加<code>Feture</code>的时候默认选取一个训练集,这样我开发的时候调试就非常方便,而且可以丢掉<code>for</code>循环,还我一个清新脱俗的<code>ipy</code>.</p>
<p>这里说一个小细节,因为我传参必须要外部调用这种,对于运行<code>ipy</code>我使用了<code>runipy</code>这个工具,然后我死活没有找到,如何使用<code>runipy</code>把参数传倒<code>ipy</code>里面去的方法(如果找到了请告诉我),我一拍脑袋那就转换成<code>py</code>文件传过去,通过<code>sys.argv</code>很轻松就能获取到,所以我又用<code>jupyter nbconvert</code>的工具把<code>ipy</code>转换成<code>py</code>文件</p>
<p>所以绕了一圈最后又回到了<code>py</code>上(手动滑稽).不过我们工作还是在<code>ipy</code>上进行,生成的<code>py</code>文件我好像没打开过….</p>
<h2 id="特征提取-extract-fetures-ipynb"><a href="#特征提取-extract-fetures-ipynb" class="headerlink" title="特征提取(extract_fetures.ipynb)"></a>特征提取(<code>extract_fetures.ipynb</code>)</h2><p>聊完如何划分数据集,现在我们进入如何特征提取,我们可以看到这次数据其实就三个特征:时间-企业-用电量.由于企业的信息只有一个<code>id</code>,所以我首先提取的是时序的特征,首先把时间分解为八个维度</p>
<ul>
<li>dayofweek</li>
<li>dayofyear</li>
<li>days_in_month</li>
<li>quarter</li>
<li>week</li>
<li>weekofyear</li>
<li>month</li>
<li>year</li>
</ul>
<p>我们可以通过<code>pandas</code>轻松提取出来</p>
<p>然后我们再从两个方向来看,第一个就是我们日总用电量特征,从全部企业日总用电量</p>
<p>第二个就是日用电量特征,从每个企业日用电量来看,这些特征我们使用简单统计又可以得到10个维度数据(mean,std,等等)</p>
<p>看完这些之后我们又可以从多个时间维度来看这些特征,比如30天前,90天前等等(我划分了30,60, 90,180,360五个),</p>
<p>这样我们就有了 <code>8 * 2 * 5 * 10</code>个特征,但是这远远达不到我们说的上万维度,</p>
<p>现在我们从业务逻辑上来思考,因为我们知道,其实我们中国节假日和周末,天气这些对用电量影响非常大(我们老家打雷就停电…..)</p>
<p>所以我们要引入外部数据集,我采用两个爬虫分别是<code>weather_crawl,holiday_crawl</code>爬取了天气和节假日的数据</p>
<p>我们按照前面的思路,从天气节假日的角度又可以划分出n多特征(这时候我的特征已经达到3000了)</p>
<p>完了这些基础特征后,我发现有些特征重要性特别大(使用<code>Randomforest</code>得到),这时候我们又要请出我们第二大神器,交叉特征,比如月和假期的特征融合,这一波操作直接让我的特征到了6000+维度(如果将窗口扩大轻轻松松上万)</p>
<p>在这里要介绍一个特征生成的方法,有时候我们特征少,我们会采用自己命名的,自己生成,然后这个由于规律性比较大,<br>如果我们自己手动一个一个写的话,这上万<code>Fetures</code>够你写的,所以要让他自己生成特征,我们只要建好模子就行,由于这次<br>时间仓促,基本上我没有自己手动命名<code>feture</code>,全部都由程序生成,省掉很多代码量,具体可以看看代码实现,原理很简单.</p>
<h1 id="训练模型-train-model-ipynb"><a href="#训练模型-train-model-ipynb" class="headerlink" title="训练模型(train_model.ipynb)"></a>训练模型(<code>train_model.ipynb</code>)</h1><p>训练模型的话,一般比赛都推荐先使用树模型,一方面速度快,第二个可以看到<code>feture</code>的重要性,这对于你挑选交叉特征非常有用,模型调参的我这里就不讲,一方面我自己也不是很懂,第二个方面也网上教程也多,我讲的不一定比他好</p>
<p>这里要推荐一个发现有趣的包,<code>mlxtend</code>,我用他来进行<code>stacking</code>特别方便,有意思的时,我用他融合了四个模型,最后我的训练结果竟然为1,完全拟合了……</p>
<p>这个包可以很简单的进行模型的<code>stacking</code>,然而这个比赛我没有把他用好(手动滑稽)</p>
<p>通过训练模型后我们把模型存到<code>pkl</code>文件中,然后在用他来预测数据,这样在文件夹里转一圈的原因,因为原来打过部分比赛数据量太大,训练模型后内存不足,只能先<code>del</code>,清空内存,再预测,存到文件夹后,结束进程,清空内存,这样就能省下空间来读取下一步数据.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实在这个脚手架上可以扩展很多东西,比如最后搏一搏单车变摩托的时候,我就在分割数据和训练数据之间加了一个过滤清洗数据层,在训练模型和融合特征之间加了一个降维的中间层.</p>
<p>建立一个好的脚手架只是能让你在增添特征,选择特征时更加轻松,其实比赛看的还是你对数据的一种掌控力,建立这个脚手架主要是为了节省更多时间给提取特征、选择特征上.特征决定你的上限.</p>
<p>这次比赛比较特殊,模型在这个比赛效果可能没有规则好,因为数据量太小,我<code>stacking</code>一下直接完全拟合了.可惜验证的次数还是<br>太少,除去前面两次错误的提交,我只有三次验证机会,如果次数多一点的话,选择特征降维或者模型调参一下遏制拟合结果可能会好很多吧.</p>
<p>但是这次比赛自己学到了如何搭一个<code>ipy</code>的管道和增加了一些特征调参、特征降维的经验。因为以前看到的搭建管道资料都是基于<code>py</code>,很少基于<code>ipy</code>的,所以把自己搭建<code>ipy</code>管道经验分享出来,也希望自己写的这篇博文能够抛砖引玉,帮助大家搭建自己的完美管道.</p>
<p>附上我的<a href="https://github.com/mrzhangboss/electricAI" target="_blank" rel="external">开源示例</a>:  <a href="https://github.com/mrzhangboss/electricAI" target="_blank" rel="external">https://github.com/mrzhangboss/electricAI</a><br>大家觉得有帮助就给我点个star吧</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/competition/">competition</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/06/13/大航杯“智造扬中”电力AI大赛参赛经验/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/06/13/大航杯“智造扬中”电力AI大赛参赛经验/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/16/如何成为一名数据挖掘机/" title="如何成为一名数据挖掘机" itemprop="url">如何成为一名数据挖掘机</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="张伦" target="_blank" itemprop="author">张伦</a>
		
  <p class="article-time">
    <time datetime="2017-05-16T11:47:12.000Z" itemprop="datePublished"> 发表于 2017-05-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>自我介绍</p>
<p>前端 - &gt; 后端  -&gt; 数据挖掘机</p>
<p>ML DM AI  的区别</p>
<p>我的自学之旅</p>
<p>给新手的推荐</p>
<ul>
<li>机器学习课程(MOOC)</li>
<li>Kaggle、天池、数据城堡</li>
</ul>
<p>掌握的技能</p>
<ul>
<li>Java + Python</li>
<li>数据可视化</li>
<li>训练团队感</li>
</ul>
<p>未来的发展方向</p>
<ul>
<li>全栈数据挖掘工程师</li>
<li>增长黑客</li>
<li>ML算法工程师</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/05/16/如何成为一名数据挖掘机/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/05/16/如何成为一名数据挖掘机/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/04/爬虫分布式总结/" title="爬虫分布式总结" itemprop="url">爬虫分布式总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="张伦" target="_blank" itemprop="author">张伦</a>
		
  <p class="article-time">
    <time datetime="2017-04-04T08:03:55.000Z" itemprop="datePublished"> 发表于 2017-04-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>由于最近在一家数据服务公司实习，项目需要了解分布式，所以在这里基于<code>scrapy</code>的分布式总结一下爬虫的分布式实习</p>
</blockquote>
<h1 id="分布式起因"><a href="#分布式起因" class="headerlink" title="分布式起因"></a>分布式起因</h1><blockquote>
<p>单机无法完成全部工作任务所以要使用集群加速完成工作任务</p>
</blockquote>
<p>分布式有点像蚁群，一只蚂蚁举不起一只卡壳虫，但是几百只就能轻松的把他运回家</p>
<p>但是分布式设计必须科学，否则就像下面一样，一个和尚挑水，其他和尚围观</p>
<p><img src="/images/timg.jpg" alt="分工不合理，来源网络"></p>
<h1 id="分布式设计"><a href="#分布式设计" class="headerlink" title="分布式设计"></a>分布式设计</h1><p>分布式设计原理在于<strong>分工</strong></p>
<p>首先我们来看看爬虫怎么进行分工，单个爬虫运行根据<code>url</code>获取响应报文，然后通过解析报文返回结果或者下一次爬取目标，如果单个爬虫我们只要在内存维持一个<code>set</code>变量记住爬取过的<code>url</code>，这就是<code>scrapy</code>默认的方法。</p>
<p>但是我们无数个爬虫由于不在同一个进程，无法共享变量，所以我们只要让一个“<code>variable</code>（变量）”能够被被所以爬虫共享到就完成了主要功能</p>
<p>现在我们来完善具体细节<br>要求：</p>
<ul>
<li>爬虫能够轻松读取所以已爬取变量</li>
<li>爬虫能够加入已读取变量</li>
<li>爬虫能够获取下一次请求具体参数</li>
</ul>
<p>原则上我们可以使用内存映射来构建这个变量，但是读取，修改都不便利，所以可以先使用<code>redis</code>作为存贮变量的地方，使用<code>redis</code>提供的<code>set</code>我们替代<code>scrapy</code>框架的<code>set</code>变量。</p>
<p>现在我们已经决定我们要使用什么容器来存贮变量，接下来我们要考虑存什么变量。</p>
<p>我们先看<code>scrapy-redis</code>存贮了什么，分析源代码可知，<code>scrapy-redis</code>将返回的<code>Request</code>pickle话存入数据库，并且计算这个<code>Request</code>的32位hash值存入<code>redis</code>的<code>set</code>中过滤列表。</p>
<p><code>scrapy-redis</code>通过修改<code>scrapy</code>的调度器（scheduler）让其当爬虫没有<code>Request</code>需要处理时在<code>redis</code>中提取<code>Request</code>，实现分布式。</p>
<p>我们来分析一下这种方法，爬虫在爬取的过程中从<code>master</code>端获取<code>Request</code>，并不断生成<code>Request</code>到<code>master</code>端，<code>master</code>只是一个<code>redis</code>数据库，负责对<code>url</code>去重，分发任务。</p>
<p>我们来比较一下直接存取<code>url</code>这种方法，这种方法好处在于，<code>slaver</code>能够从上一个<code>Request</code>中获取全部信息，假如上一个<code>Request</code>需要存取获取的表单提取地址，我们下一次爬虫发起<code>Request</code>就能从上一个<code>Request</code>中获取参数。</p>
<p>当然由于我们存贮的是<code>Request</code>，一个<code>Request</code> <code>pickle</code>化之后的字符串比较长，当我们的任务列表里面有很多<code>Request</code>的时候，<code>redis</code>占用的内存会非常巨大。</p>
<p>当然如果爬虫启动的够多，生成一个就能把任务被调度下去，那么这个任务列表就能稳定在一个可控的范围。</p>
<p> <strong>总结</strong></p>
<p>每个爬虫即负责爬取数据，又负责生成下一个任务，即无主次之分，我们可以一次性在<code>docker</code>中启动上百个实例，我们只是用<code>redis</code>充当一个存放<code>变量</code>的地方。</p>
<p>但是这种方法也有一个缺点，我们不能自由的添加初始<code>url</code>，要想添加新的爬取任务，必须新建一个爬虫更新初始<code>url</code>，我们如果是想搭建一个自由添加<code>url</code>的爬虫，这种实现方式不大优雅。</p>
<h1 id="分布式改良"><a href="#分布式改良" class="headerlink" title="分布式改良"></a>分布式改良</h1><p>我们要修改程序框架，达到随时可以添加要爬取新任务，然而不影响爬虫集群</p>
<p><img src="/images/distribute_crawl.png" alt="爬虫框架"></p>
<p>我们独立出来<code>master</code>，<code>master</code>负责生成<code>Request</code>去重以及任务调度，而<code>slaver</code>只负责从<code>master</code>获取任务爬取。</p>
<p>这种方法我们可以很轻松对<code>master</code>改良而不影响<code>slaver</code>，通过让<code>master</code>定时从<code>数据库</code>中获取新的任务生成到任务列表，我们可以轻松添加新的任务到<code>slaver</code>集群中去。</p>
<p>下一步我们就介绍如何修改<code>scrapy-redis</code>达到我们新框架需要</p>
<h1 id="重构scrapy-redis"><a href="#重构scrapy-redis" class="headerlink" title="重构scrapy-redis"></a>重构<code>scrapy-redis</code></h1><p>参考：<br><a href="http://blog.csdn.net/bone_ace/article/details/50989104" target="_blank" rel="external">基于Redis的三种分布式爬虫策略</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/programming/">programming</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/04/04/爬虫分布式总结/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/04/04/爬虫分布式总结/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/03/15/协程解决递归错误/" title="协程解决递归错误原理" itemprop="url">协程解决递归错误原理</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="张伦" target="_blank" itemprop="author">张伦</a>
		
  <p class="article-time">
    <time datetime="2017-03-14T16:00:00.000Z" itemprop="datePublished"> 发表于 2017-03-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote>
<p>递归是高度抽象化问题的一个好东西，我们能从很多算法书里面看到这个，<br>但是递归虽然对于人来说好理解，但是计算机执行起来会损失性能，一个差的递归可能会耗光计算机的资源</p>
</blockquote>
<p>接下来我们来看一个非常经典的算法问题<code>Fibonacci数</code></p>
<pre><code>f(n) = n (n &lt; 2)
f(n) = f(n-1) + f(n-2)   (n &gt;= 2)
</code></pre><p>  我们可以很轻松的用递归解决掉它</p>
<pre><code>def fibonacci(n):
  if n &lt; 2:
      return n
  else:
      return fibonacci(n-1) + fibonacci(n-2)
</code></pre><p> 当<code>n</code>比较小的时候很快就出结果了，但是当<code>n</code>大于100时候要很久才能出结果，如果<code>n</code>大于1000，直接报出超出迭代深度的错误（python默认迭代深度是1000）</p>
<p>现在我们来解决两个问题</p>
<ol>
<li>为什么<code>n</code>大于100时候就很久才能算出结果</li>
<li>为什么<code>n</code>大于1000就报迭代深度的错误</li>
</ol>
<p>首先我们要知道一个概念就是堆栈段，每个进程开始运行时都会初始化一个堆栈段，这在物理上就是一小块内存，初始化堆栈段的时候计算机要做一些看起来同程序毫无关系的事情，比如说将寄存器的值推入堆栈里面等等</p>
<p>当你在运行主程序的时候你调用一个子函数，系统又会在当前堆栈段新建一个堆栈段，你子程序运行完了后会删掉这个堆栈段回到主程序，但是递归有个问题，就是他调用子程序的时候不会立即返回又会再调用自己</p>
<p>没办法因为子程序还没返回，所以计算机又初始化一个堆栈段，一个<code>n</code>为10的<code>fibonacci</code>函数就会初始化掉 <code>2 ** 10 = 1024</code>个堆栈段，<code>n</code>越大值会指数型增长，虽然1000个初始化在当今计算机上发不了多少时间，但是当我们<code>n</code>大于20就要 百万次初始化了</p>
<p>这就是为什么<code>n</code>很大的时候要很久才能算出结果，在一些单片机上面，循环调用空函数就是延时的功能，原理也就是堆栈初始化耗时间，而且不但耗时间假如像递归这样调用上百万次初始化而不返回将会耗掉大量内存在堆栈段上。</p>
<h2 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h2><blockquote>
<p>要解决这两个问题，一种方法是改算法，使用非递归算法，这个网上有很多，感兴趣的可以去搜一下，第二种是使用协程解决递归问题</p>
</blockquote>
<p>如何使用协程来解决递归呢我们先改主程序，将<code>return</code>换成<code>yield</code></p>
<pre><code>def _fibonacci(n):
  if n &lt; 2:
      yield n
  else:
      yield ( (yield (_fibonacci(n-1)) + (yield (_fibonacci(n-2)))
</code></pre><p>接下啦我们运行一下函数</p>
<pre><code>&gt;&gt;&gt; _fibonacci(10)
 &lt;generator object _fibonacci at 0x00000013A74779E8&gt;
</code></pre><p>没有返回结果,返回一个生成器，那我们用<code>list</code>简单的试一下吧</p>
<pre><code>&gt;&gt;&gt; list(_)
......
......
TypeError: unsupported operand type(s) for +: &apos;NoneType&apos; and &apos;NoneType&apos;
</code></pre><h4 id="生成器小知识"><a href="#生成器小知识" class="headerlink" title="生成器小知识"></a>生成器小知识</h4><blockquote>
<p>这里补充几点生成器的知识，懂得可以跳过</p>
</blockquote>
<p>生成器大家都用过，无论是<code>Python2</code>或<code>Python3</code>都不陌生,最简单的生成器是这种</p>
<pre><code>&gt;&gt;&gt; items = ( x for x in range(10))
</code></pre><p>我们一般搭配<code>for</code>来使用</p>
<pre><code>&gt;&gt;&gt; for i in items:
...         print(i)
...
</code></pre><p>我们也可以用协程来实现这个生成器</p>
<pre><code>def iter_func(n):
    for i in range(n):
        yield n
</code></pre><p>像上面一样使用<code>for</code>就能实现一样的功能，在这个例子里面<code>yield</code>好像变成了一个<code>return</code>的作用，在<code>for</code>语句中，随着每次请求都会<code>return</code>一个数过来</p>
<p>在这个里面<code>yield</code>好像就是这么个功能，但是<code>yield</code>的作用远远不止于此</p>
<p>我们现在来改一下这个函数</p>
<pre><code>def iter_func(n):
    for i in range(n):
        r = yield i
        print(&apos;result&apos;, r)
</code></pre><p>我们用<code>list</code>来运行一下这个函数</p>
<pre><code>&gt;&gt;&gt; list(iter_fun(2))
0
result None
1
result None
</code></pre><p><code>r</code>返回了一个<code>None</code>，我们尝试自己实现一下<code>for</code>循环,有两种方式</p>
<ul>
<li>next(generator)</li>
<li>generator.send(msg)</li>
</ul>
<p>先尝试用<code>next</code></p>
<pre><code>&gt;&gt;&gt; it = iter_fun(2)
&gt;&gt;&gt; next(it)
0
&gt;&gt;&gt; next(it)
result None
1
</code></pre><p>我们介绍一下<code>next</code>函数, <code>next</code>接受两个参数，第一个是生成器，第二个是返回的默认值,<code>next</code>函数在这里相当于下面这个函数</p>
<pre><code>def next(iterator, default=None):
    try:
        iterator.send(None)
    except StopIteration:
        if default:
            return default
        else:
            raise StopIteration()
</code></pre><p><strong>为什么第二个执行了<code>print</code>函数而第一个没有执行?</strong></p>
<h4 id="生成器工作原理"><a href="#生成器工作原理" class="headerlink" title="生成器工作原理"></a>生成器工作原理</h4><blockquote>
<p>这里我们介绍一下生成器的工作原理</p>
</blockquote>
<p>当我们使用调用一个函数的时候，一般是碰到<code>return</code>或者执行全部函数就会返回父函数</p>
<p>但是<strong>生成器</strong>不同，假如他执行函数碰到<code>yield</code>，他就会直接返回一个生成器。</p>
<p>这个生成器我们可以把它看做是邮递员，我们必须写好目的地,他才会帮我们把信寄出去。</p>
<p>现在我们分析一下生成器的具体流程，我们先定义一个简单的生成器</p>
<pre><code>def mygenerator(n):
    while True:
        r = yield n
        n -= 1
        print(&apos;result&apos;, r)
</code></pre><p> 然后我们调用这个生成器</p>
<pre><code>&gt;&gt;&gt; i = mygenerator(10)
&gt;&gt;&gt; i
&lt;generator object mygenerator at 0x7f420a339d00&gt;
</code></pre><p>我们得到一个生成器，我们先尝试发送一个地址给“邮递员”</p>
<pre><code>&gt;&gt;&gt; i.send(0)
...
TypeError: can&apos;t send non-None value to a just-started generator
</code></pre><p>我们得到一个错误，必须传递一个<code>None</code>，我们先不管，先送一个<code>None</code>值过去</p>
<pre><code>&gt;&gt;&gt; i.send(None)
10
</code></pre><p>我们得到一个<code>10</code>，再送一个地址过去</p>
<pre><code>&gt;&gt;&gt; i.send(None)
result None
9
</code></pre><p>我们现在来分析一下代码，第一次调用的时候直接返回了，第二次调用我们从<code>r = yield n</code>那行开始执行，并且运行到第二个<code>r = yield n</code>那里停止了</p>
<p><strong>就可以解释上面为什么要第一次传递<code>None</code>过去，因为第一次调用它会直接返回<code>yield</code>后面的值给我们，第二次调用 我们可以根据第一次生成器递给我们的值，决定我们第二次想寄的“信”，因为第一次传递过去“信”并不能被处理，所以Python强制我们传递一个None值过去</strong></p>
<hr>
<blockquote>
<p>我们回到上面的函数</p>
</blockquote>
<pre><code>def _fibonacci(n):
    if n &lt; 2:
        yield n
    else:
        yield ( (yield (_fibonacci(n-1)) + (yield (_fibonacci(n-2)))
</code></pre><p>我们来分析一下流程，为了解决上面的问题我们先把函数简化，去掉递归</p>
<pre><code>def f(n):
    yield (yield n) + (yield n - 1)
</code></pre><p>我们先创建一个生成器<code>i</code></p>
<pre><code>&gt;&gt;&gt; i = f(5)
&gt;&gt;&gt; i
 &lt;generator object f at 0x7f4a421d8f10&gt;
</code></pre><p>我们先启动i</p>
<pre><code>&gt;&gt;&gt; i.send(None)
5
</code></pre><p>我们再把得到<code>5</code>传给<code>i</code></p>
<pre><code>&gt;&gt;&gt; i.send(5)
4
</code></pre><p>我们得到<code>yield n -1</code>返回的4，我们再把4传给<code>i</code>，得到最终结果</p>
<pre><code>&gt;&gt;&gt; i.send(5)
9
</code></pre><p>假如我们把后面两个<code>send</code>的值换成其他值我们会得到不同的结果，这里我们可以看到我们，要实现上面函数必须要依靠一个<code>栈</code>，保存我们返回的生成器，然后依次调用生成器返回结果，具体代码如下</p>
<pre><code>def fibonacci(n):
    stack = [ _fibonacci(n)]
    last_result = None
    while stack:
        last = stack[-1]
        try:
            if isinstance(last, types.GeneratorType):
                stack.append(last.send(last_result))
                last_result = None
            else:
                last_result = stack.pop()
         except StopIteration:
             stack.pop()
     return result
</code></pre><p>我们这里用<code>stack</code>作为我们的堆栈，用<code>last_result</code>保存上一个生成器返回的值</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们使用协程解决掉了递归错误，但是这个方法并不可以给我们算法加速，虽然n为1000以上不会报递归错误，但是等待的时间还是很长很长。。。</p>
<p>虽然协程在这个方法里面并没有起到多大作业，协程在算法方面还是没有太多帮助，协程在计算机<code>I/O</code>还有网络请求方面有更好的效率，但是这次尝试让我们对协程如何使用有了一个清晰的了解</p>
<p>有兴趣的可以去了解一下协程在异步网络请求的应用</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/python/">python</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/03/15/协程解决递归错误/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/03/15/协程解决递归错误/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/02/17/天池大赛-口碑预测参赛感想/" title="天池大赛-口碑预测参赛感想" itemprop="url">天池大赛-口碑预测参赛感想</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="张伦" target="_blank" itemprop="author">张伦</a>
		
  <p class="article-time">
    <time datetime="2017-02-17T13:15:19.000Z" itemprop="datePublished"> 发表于 2017-02-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>第一次听说这个比赛还是去年在知乎上，当时也不知道这个比赛具体是怎么回事，当时自己还是一个小白，忙着搞懂各种主流的机器学习模型算法。</p>
</blockquote>
<p>当时在我心中，模型算法是数据挖掘的最重要的组成部分，搞懂这些才能真正搞定数据挖掘。我当时对算法模型和数据的理解是：模型就是风车，数据就是流水。我要做的事就是撘一个强健的风车，让数据流过。</p>
<p>当我还没接触实际的工作前，我还没有没有从编程工转向挖掘工。我太注重编程本身了，而忘记我自己真正要挖掘的宝藏。</p>
<p>我以前在<code>Quora</code>上搜如何成为数据科学家，我发现很多有经验的数据科学家他们都把“对数据的敏感和兴趣”作为数据科学家最重要的特征，而“了解各种算法模型并能应用到数据上”才是第二重要的。我当时不是太理解，我觉得后者才是更重要的。</p>
<h2 id="参赛感想"><a href="#参赛感想" class="headerlink" title="参赛感想"></a>参赛感想</h2><p>这次参赛算是我学习数据挖掘第一次实际的挖掘，以前学习各种算法模型都是准备的很好的数据，只要套上算法模型就能跑的很好。所以我一开始就拼命的去找类似的大赛，看看获胜者他们用的模型是什么。</p>
<p>这几天我好像抱着一堆瓶子，拼命的想把巨大的石头（数据）塞进瓶口里，看起来工作量很大，流了很多汗，其实什么都没有干。今天在看一个类似的比赛选手答辩的时候的视频，突然明白自己好像走了一个死胡同。自己拼命的想这找一个合适的瓶子（模型），其实我更应该做的是把石头（数据）磨碎。</p>
<h4 id="模型本身不重要，他只是一个载体，更重要的是数据。"><a href="#模型本身不重要，他只是一个载体，更重要的是数据。" class="headerlink" title="模型本身不重要，他只是一个载体，更重要的是数据。"></a>模型本身不重要，他只是一个载体，更重要的是数据。</h4><p>第一次参加这样大型比赛，有点激动也有点惶恐，如何将所学的应用到实际，还有在实际中提高自己还有待自己“挖掘”。虽然这个比赛奖金“丰富”，但是我觉得在这个比赛中得到的体会乐趣比奖金更诱人。</p>
<hr>
<p>比赛还有一个月，在这里立个小目标，争取跑到到前五页，我也会尽量抽时间把自己感想写出来。<br>未完待续。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/competition/">competition</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/02/17/天池大赛-口碑预测参赛感想/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/02/17/天池大赛-口碑预测参赛感想/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/12/23/how-to-be-data-scientist/" title="怎么成为数据科学家（翻译）" itemprop="url">怎么成为数据科学家（翻译）</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="张伦" target="_blank" itemprop="author">张伦</a>
		
  <p class="article-time">
    <time datetime="2016-12-23T14:05:56.000Z" itemprop="datePublished"> 发表于 2016-12-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>这是我从<code>Quora</code>上看到的一篇非常简短但详细的数据科学家的‘技能点’<br>来自eBay的一个数据科学家的回答<br>翻译来自<a href="https://www.quora.com/How-do-I-become-Data-analyst-scientist-Do-I-need-to-have-good-programming-skills/answer/Paul-Jeon-3?srid=ue3s8" target="_blank" rel="external">Quora回答</a></p>
</blockquote>
<p>这是面试谷歌、英特尔、脸书等大的世界五百强公司的数据科学家相关岗位常见的技术要求，在我看来主要有七点</p>
<ul>
<li>基本的编程基础</li>
</ul>
<blockquote>
<p>你应该了解一门统计学相关的编程语言，比如说<code>R</code>或<code>Python</code>（同时要了解<code>Numpy</code>和<code>Pandas</code>库），还要一门数据库查询语言比如<code>SQL</code></p>
</blockquote>
<ul>
<li>统计学</li>
</ul>
<blockquote>
<p>你应该要能解释零假设、P值、最大似然估计和置信空间这些短语，统计学在非常巨大的数据库里压缩数据和从挑选最重要的特征非常重要，在你得出结论和设计实验过程中也帮助巨大</p>
</blockquote>
<ul>
<li>机器学习</li>
</ul>
<blockquote>
<p>你必须能够搞懂K-近邻、随机森林和集合方法等机器学习算法，这些算法基本上都在<code>R</code>或<code>Python</code>中得到实现，这些算法能告诉你雇主你能够将计算机科学运用在实际的管理中。</p>
</blockquote>
<ul>
<li>数据重组</li>
</ul>
<blockquote>
<p>你应该要能够“清理”数据。比如数据库中”California” （加利福利亚）和“CA”是一样的，数据库里面可能出现用负值代表人口。这个总的来说就是识别坏（或者不正确）的数据然后校正（或删除)他们。</p>
</blockquote>
<ul>
<li>数据可视化</li>
</ul>
<blockquote>
<p>数据科学家不能就只是自己搞懂就行，他们需要把他们发现告诉你的产品经理，这样就能确保数据能很好的应用到程序里面去。所以，熟悉数据可视化工具比如说<code>ggplot</code>非常重要（这样你就能展示你的数据而不是仅仅谈谈而已）</p>
</blockquote>
<ul>
<li>软件工程</li>
</ul>
<blockquote>
<p>你应该了解算法和数据结构，因为这些东西在你写高效率的机器学习算法时非常重要，知道如何使用分支和使用高效的数据结构：队列、数组、列表、堆栈、树等等。</p>
</blockquote>
<ul>
<li>产品管理</li>
</ul>
<blockquote>
<p>这个绝对是有争议的，但是那些了解产品的人将会知道什么指标是最重要的。这里有很多数据可以用来做A/B测试，但是产品导向的数据科学家将会把最好的指标用来做测试。你要知道这些的意思：可用性测试、线框、保留和转换率、流量分析、客户反馈、内部日志、A/B测试。</p>
</blockquote>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/transform/">transform</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/12/23/how-to-be-data-scientist/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/12/23/how-to-be-data-scientist/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/10/09/ansible管理nginx负载均衡/" title="ansible管理nginx负载均衡" itemprop="url">ansible管理nginx负载均衡</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="张伦" target="_blank" itemprop="author">张伦</a>
		
  <p class="article-time">
    <time datetime="2016-10-09T15:15:06.000Z" itemprop="datePublished"> 发表于 2016-10-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>因为手头自己有三个服务器，所以想折腾一下负载均衡。</p>
</blockquote>
<p>两个<code>CentOS</code>，一个<code>Ubuntu</code>,都是比较新的。</p>
<p>一开始准备用<code>haproxy</code>来做负载均衡服务器，因为<code>haproxy</code>相比与<code>nginx</code>对<code>cookie</code>和<code>session</code>支持比较好，但是由于两个原因还是放弃了。</p>
<ol>
<li>服务器被阿里云封掉</li>
</ol>
<blockquote>
<p>简单的在<code>haproxy</code>中设置后端服务器后，过一段时间就显示强制备案页面，由于我的域名没有备案。</p>
</blockquote>
<p>后来我翻看了<code>nginx</code>日志发现，<code>haproxy</code>默认在<code>request header</code>里面带了<code>X-Host</code>，被阿里云发现了，这里提供一个解决方法</p>
<pre><code># 删除掉你header里面的 Host
# 在backend里面添加一句
http-request del-header Host
</code></pre><p>然而<code>nginx</code>里面默认是没有添加<code>Host</code>这个的，要你在<code>localtion</code>中添加两句，如下面</p>
<pre><code>    server {
  listen 80;
  server_name example.com;
  location / {
    proxy_pass       http://main;
    proxy_set_header Host            www.example.com; # add Host
        proxy_set_header X-Forwarded-For $remote_addr; # add X-Forwarded
  }
}
</code></pre><ol>
<li>haproxy支持多开</li>
</ol>
<blockquote>
<p>我试了很多种选项，确定<code>pidfile</code>、改变<code>uid</code>、<code>gid</code>等等，<code>haproxy</code>似乎可以允许很多个相同进程绑定同一个端口，虽然可以通过<code>pid</code>来写一套类似<code>service</code>管理的脚本，但终归很麻烦</p>
</blockquote>
<p>我看网上有人写了这个脚本，但是<code>nginx</code>自带了，还是用<code>nginx</code>比较好，而且<code>ansible</code>与<code>service</code>的交互还不错。</p>
<h2 id="nginx负载均衡"><a href="#nginx负载均衡" class="headerlink" title="nginx负载均衡"></a>nginx负载均衡</h2><blockquote>
<p>nginx负载均衡是通过反向代理来实现的，也就是把一台服务器的压力分摊到多台上面</p>
</blockquote>
<p>要想实现这个必须要有后端服务器，假设我们有一台后端服务器<code>1.1.1.1</code>，在代理主机的<code>nginx</code>配置系统<code>location</code>里面只要添加一条<code>proxy_pass</code>就行了</p>
<pre><code>    server {
listen 80;
server_name example.com;
location / {
    proxy_pass http://1.1.1.1;
}
}
</code></pre><p>  上面只是简单的实现了一个反向代理的功能，当你有一个后端服务群的时候，你就要使用负载均衡模块了，负载均衡模块在<code>nginx</code>配置特别简单，添加一个<code>upstream</code>模块，把服务器ip或者域名放到里面</p>
<pre><code>  upstream webservers{
    server 1.1.1.1 weight=10;
    server my.domain.com  weight=10;

}
</code></pre><p>  然后修改<code>proxy_pass</code>后的为<code>http://webservers</code>就行了</p>
<p>  ps： <code>nginx</code>对于后端反向代理服务器有个<code>max_fails</code>和<code>fail_timeout</code>属性，你要是设定了一个<code>max_fails</code>次数，你代理服务器拿取失败了几次就会在<code>fail_timeout</code>值之后尝试，和<code>haproxy</code>的<code>retry</code>属性差不多，但是似乎<code>haproxy</code>的<code>retry</code>不好使，我故意使用两个错误<code>ip</code>和正确<code>ip</code>，结果<code>nginx</code>能一直正确返回正确<code>ip</code>响应，而<code>haproxy</code>有时候能，有时候不行。</p>
<h2 id="nginx错误日志"><a href="#nginx错误日志" class="headerlink" title="nginx错误日志"></a>nginx错误日志</h2><blockquote>
<p>在调试<code>nginx</code>碰到一些错误，记录一下如何系统的解决方法</p>
</blockquote>
<ul>
<li>调用<code>service nginx start</code>失败</li>
</ul>
<p>首先看给的错误信息，假如让你看<code>systemctl status nginx.service</code>或<code>journalctl -xn</code>，输入去看</p>
<ol>
<li>格式错误（format error）</li>
</ol>
<p>一般你写的<code>nginx</code>的配置文件有问题，这时候可以用<code>nginx -t</code>检查格式，修改正确后会显示<code>success</code></p>
<ol>
<li>无法绑定地址（bind error）</li>
</ol>
<p>一般是因为有别的应用程序占用端口造成的，这时候用<code>netstat -tulpn</code>检查端口，然后选择<code>kill</code>掉占用端口的程序或者换一个端口</p>
<h2 id="ansible-playbook-编写"><a href="#ansible-playbook-编写" class="headerlink" title="ansible playbook 编写"></a>ansible playbook 编写</h2><blockquote>
<p>具体代码可以参考<a href="https://github.com/mrzhangboss/nginx-load-balance-ansible-playbook" target="_blank" rel="external">nginx均衡负载ansible-playbook</a><br>首先你得写一个<code>hosts</code></p>
</blockquote>
<pre><code>[ali]
my ansible_ssh_host=1.1.1.1 ansible_ssh_user=root 
[tencent]
main ansible_ssh_host=1.1.1.2 ansible_ssh_user=root
[digital]
google ansible_ssh_host=1.1.1.3 ansible_ssh_user=root
</code></pre><p>前面<code>[  ]</code>包着的是组名，最前面的<code>my</code>和<code>main</code>和<code>google</code>是<code>别名</code>，后面就是ip和用户名了。</p>
<p>写完<code>hosts</code>后要写两个<code>nginx</code>配置文件一个代理服务器的配置文件和一个后端服务器配置文件，<code>playbook</code>很简单就是复制<code>nginx</code>配置文件和重启<code>nginx</code>。</p>
<pre><code>---
- hosts: tencent
  remote_user: root

    tasks:
  - name: copy nginx config file 
    template: src=~/test/lunge_proxy.conf  dest=/etc/nginx/conf.d/lungelog.conf
    notify: restart nginx

    handlers:
  - name: restart nginx
    service: name=nginx state=restarted enabled=yes
</code></pre><p>解释一下<code>notify</code>，在复制完成之后就启用一个<code>handler</code>完成<code>nginx</code>的重启，当然这里也可以使用<code>reload</code>，假如在生产环境的话。</p>
<p>客户端和代理的<code>playbook</code>差不多就不多介绍了。</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p><a href="https://www.zybuluo.com/phper/note/90310" target="_blank" rel="external">nginx的配置、虚拟主机、负载均衡和反向代理</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/software/">software</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/10/09/ansible管理nginx负载均衡/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/10/09/ansible管理nginx负载均衡/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/3/"><span></span>Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/summary/" title="summary">summary<sup>11</sup></a></li>
			
		
			
				<li><a href="/tags/programming/" title="programming">programming<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/python/" title="python">python<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/software/" title="software">software<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/mit6-828/" title="mit6.828">mit6.828<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/github/" title="github">github<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/HTTP/" title="HTTP">HTTP<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/competition/" title="competition">competition<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/TDD/" title="TDD">TDD<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/software-DL/" title="software, DL">software, DL<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/transform/" title="transform">transform<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/js/" title="js">js<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/DL/" title="DL">DL<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/python3/" title="python3">python3<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://segmentfault.com/ " target="_blank" title="一个面向程序员交流分享的新一代社区">segmentfault</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=5364356330&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m zhanglun. <br/>
			This is my blog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/5364356330" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/mrzhangboss" target="_blank" class="icon-github" title="github"></a>
		
		
		<a href="http://stackoverflow.com/users/6599843" target="_blank" class="icon-stack-overflow" title="stackoverflow"></a>
		
		
		<a href="https://twitter.com/mrzhangboss" target="_blank" class="icon-twitter" title="twitter"></a>
		
		
		<a href="https://www.facebook.com/100011375031071" target="_blank" class="icon-facebook" title="facebook"></a>
		
		
		
		
		<a href="http://www.zhihu.com/people/zhang-lun-59-53" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
		<a href="mailto:2529450174@qq.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 
		
		<a href="/about" target="_blank" title="张伦">张伦</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-80810286-1,UA-80810286-2', 'auto,auto');  
ga('send', 'pageview');
</script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
