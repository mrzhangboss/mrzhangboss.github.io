
 <!DOCTYPE HTML>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
  
    <title>lunge博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="张伦">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="lunge博客">
<meta property="og:url" content="https://mrzhangboss.github.io/page/2/index.html">
<meta property="og:site_name" content="lunge博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lunge博客">
<meta name="twitter:creator" content="@mrzhangboss">

    
    <link rel="alternative" href="/atom.xml" title="lunge博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/logo2.png">
    
    
    <link rel="apple-touch-icon" href="/img/logo2.png">
    <link rel="apple-touch-icon-precomposed" href="/img/logo2.png">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo2.png" alt="lunge博客" title="lunge博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="lunge博客">lunge博客</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="搜索" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/13/大航杯“智造扬中”电力AI大赛参赛经验/" title="如何搭建自动生成上万特征的管道" itemprop="url">如何搭建自动生成上万特征的管道</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="张伦" target="_blank" itemprop="author">张伦</a>
		
  <p class="article-time">
    <time datetime="2017-06-13T10:56:31.000Z" itemprop="datePublished"> 发表于 2017-06-13</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>基于:大航杯“智造扬中”电力AI大赛参赛经验</p>
<p><img src="/images/electric_power_ai.jpg" alt="大航杯AI大赛"></p>
<p>赛题背景</p>
<blockquote>
<p> 主办方为大航集团提供21个月江苏省杨中市1454家企业日用电量,来估计下一个月日总用电量</p>
</blockquote>
<p>从给的数据分析,这次给的数据只有历史企业日用电量,用来估计日总用电量,是一个典型的时域分析问题</p>
<p>但是这同我们以往的时序问题不一样,向往常时序问题预测的是每个企业的未来每日的用电量,而这个比赛却是求全部企业的总数.</p>
<p>由于我报名比赛时候比较晚,比赛已经接近尾声,比赛5月18号开始,6月8号中午切换数据,13号截止,我6月8号晚上下载数据,由于我以前已经做了几个类似的比赛,但是一直没有系统的做一个,抱着锻炼的自己的态度,决定系统做一次,权当练手.</p>
<p>首先分析一下提交的结果,预测一个月的日总用电量,总共为31个数据,给的历史数据只有21个月的,按月的比例来看,只有21个值去训练值去预测一个值,根据往常的比赛经验来看,这种比赛适合使用规则方法来做,然而我剩下的验证机会不多了,只能用模型,但是过拟合的危险非常大,如果不能找到一个好的方法克服过拟合,复赛都进不去.</p>
<p>当然最后还是没有找到一个很好的办法,止步于复赛,不过这次比赛让我学到很多,主要通过这次比赛自己琢磨出来自己如何搭建基于<code>IPython Notebook</code>的管道结构,这个管道帮我自动生成上万特征.</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><blockquote>
<p>什么是管道,在数据挖掘比赛中很多大神都着重讲了一定要搭建一个自动化的架构,我们暂且称他为”管道”,这个”管道”我们要能够把数据倒进去,结果倒出来.</p>
</blockquote>
<p>这个管道用专业的术语来看要有以下几个功能</p>
<ul>
<li>能够自由添加<code>Feture</code></li>
<li>能够自动评判得到添加的<code>Feture</code>的效果</li>
<li>管道能够自己选择合适的参数训练模型</li>
<li>能够输出结果</li>
</ul>
<p>其实简单来说,我们要做的是一个能够非常方便的扩展的脚手架,我们不可以第一次就把所以的特征全部找出来,所以我们要搭建一个能够实时添加<code>Feture</code>的框架.</p>
<p>其实很早以前就看过类似文章,也有很多人推荐<a href="https://github.com/ChenglongChen/Kaggle_HomeDepot" target="_blank" rel="external">大神开源的一个脚手架</a>,然而找到的大多是用<code>python</code>实现</p>
<p>我因为一开始就是使用<code>Notebook</code>进行数据挖掘,主要<code>Notebook</code>能够提供一个实时的反馈,而纯<code>python</code>,对于复杂多变的数据来说,显得非常笨重,你经常有个好想法想验证一下,又得重新跑一遍,尤其是对于我的机器配置来说,重新跑一边的时间都够我喝杯茶了.而且<code>notebook</code>有个特点,可视化特别方便,有时候从数据上看不到,可以画个图表</p>
<p>好了,夸了这么久,现在就来仔细讲讲脚手架如何搭建.</p>
<p>我们先回到赛题,第一步审题,当时我看到日平均两个字,直接把日字省略,看成平均用电量,结果白白浪费了两个验证机会…..</p>
<p>审完了题我们来看我们要提交的数据,换数据后要预测十月日用电总量.我们来看看给我们数据,只有一份数据,表头如下</p>
<pre><code>record_date,user_id,power_consumption
2015/1/1,1,1135
2015/1/2,1,570
2015/1/3,1,3418
2015/1/4,1,3968
2015/1/5,1,3986
</code></pre><p>解释一下字段,<code>record_date</code>–日期,<code>user_id</code>–企业id, <code>power_consumption</code>–日用电量<br>非常简单,就这么简单单单的数据,我现在要教大家怎么从这么简单的数据上抽取6000维度的</p>
<p>我把代码已经推到<code>Github</code>上了(由于数据比较少,我把数据也推上去了,方便大家本地跑跑,看完如果对你有帮助的话,请不要吝啬你的star哦),我就对照我的代码解释如何搭建一个可以跑出上万维度的脚手架</p>
<h2 id="数据划分-split-samples-ipynb"><a href="#数据划分-split-samples-ipynb" class="headerlink" title="数据划分(split_samples.ipynb)"></a>数据划分(<code>split_samples.ipynb</code>)</h2><p>首先要搭建本地预测集,也就是线下样本(这个很重要,有时候线下的结果很大程度对应你线上的结果)</p>
<p>给的数据要我们从前面21个月预测下一个月的日总用电量,我们很容易就能想到,那我们用前面20个月预测第21个月来做线下测试,但是这样我们就只有30个训练样本,要来预测30个,99.999%过拟合啊,首先我们要扩大样本,我们采用滑动移窗的方法把预测的样本按照月份推移,也就是分别预测9月8月7月等等</p>
<p>这种方法在实现<code>Notebook</code>有几个难点,首先你划分了预测集,那么就也要划分训练集,就相当于把一份数据切分成好几份,切分完之后有个问题,你必须要隔离每个部分</p>
<p>举个例子,我们把训练集划分成为2份,1月到7月预测8月,2月到8月预测9月,训练1-7月数据集的时候,我们不能让这个训练集接触到2月到8月的数据,因为8月对于前一个训练集来说是未知的,<br>如果我们让第一个训练集接触倒第二个训练集我们称为信息泄露,很影响线上的结果</p>
<p>我们知道这个问题之后,我们就要用巧妙的方法来解决,首先我们要考虑我们代码的复杂度,以前我的解决训练集隔离的方法采用的是循环法,使用一个列表存贮所以训练集,然后使用<code>for</code>循环分别传参到函数里面,这个方法能解决隔离训练集,但是有几个问题</p>
<p>在单个<code>ipy</code>文件中训练所以的样本,在测试的时候跑起来太慢,而且要把数据全部加载在内存里面,这次数据量还算小,但是对于某些小内存的电脑来说,这种方法时不时就得报<code>Memory Error</code>,而且感觉调试起来特别麻烦,所以一直在寻找更好的解决方案.</p>
<p>这次想到了一种巧妙的方法,虽然有点取巧但是效果我很满意.</p>
<p>我们先看到<code>split_samples.ipynb</code>文件,首先我把数据划分为9个样本,一个预测样本.分别放入不同文件夹进行物理隔离.但是名字相同.</p>
<p>再其次我让<code>ipy</code>能够获取参数,这样我通过外部参数就能更换数据集,平常添加<code>Feture</code>的时候默认选取一个训练集,这样我开发的时候调试就非常方便,而且可以丢掉<code>for</code>循环,还我一个清新脱俗的<code>ipy</code>.</p>
<p>这里说一个小细节,因为我传参必须要外部调用这种,对于运行<code>ipy</code>我使用了<code>runipy</code>这个工具,然后我死活没有找到,如何使用<code>runipy</code>把参数传倒<code>ipy</code>里面去的方法(如果找到了请告诉我),我一拍脑袋那就转换成<code>py</code>文件传过去,通过<code>sys.argv</code>很轻松就能获取到,所以我又用<code>jupyter nbconvert</code>的工具把<code>ipy</code>转换成<code>py</code>文件</p>
<p>所以绕了一圈最后又回到了<code>py</code>上(手动滑稽).不过我们工作还是在<code>ipy</code>上进行,生成的<code>py</code>文件我好像没打开过….</p>
<h2 id="特征提取-extract-fetures-ipynb"><a href="#特征提取-extract-fetures-ipynb" class="headerlink" title="特征提取(extract_fetures.ipynb)"></a>特征提取(<code>extract_fetures.ipynb</code>)</h2><p>聊完如何划分数据集,现在我们进入如何特征提取,我们可以看到这次数据其实就三个特征:时间-企业-用电量.由于企业的信息只有一个<code>id</code>,所以我首先提取的是时序的特征,首先把时间分解为八个维度</p>
<ul>
<li>dayofweek</li>
<li>dayofyear</li>
<li>days_in_month</li>
<li>quarter</li>
<li>week</li>
<li>weekofyear</li>
<li>month</li>
<li>year</li>
</ul>
<p>我们可以通过<code>pandas</code>轻松提取出来</p>
<p>然后我们再从两个方向来看,第一个就是我们日总用电量特征,从全部企业日总用电量</p>
<p>第二个就是日用电量特征,从每个企业日用电量来看,这些特征我们使用简单统计又可以得到10个维度数据(mean,std,等等)</p>
<p>看完这些之后我们又可以从多个时间维度来看这些特征,比如30天前,90天前等等(我划分了30,60, 90,180,360五个),</p>
<p>这样我们就有了 <code>8 * 2 * 5 * 10</code>个特征,但是这远远达不到我们说的上万维度,</p>
<p>现在我们从业务逻辑上来思考,因为我们知道,其实我们中国节假日和周末,天气这些对用电量影响非常大(我们老家打雷就停电…..)</p>
<p>所以我们要引入外部数据集,我采用两个爬虫分别是<code>weather_crawl,holiday_crawl</code>爬取了天气和节假日的数据</p>
<p>我们按照前面的思路,从天气节假日的角度又可以划分出n多特征(这时候我的特征已经达到3000了)</p>
<p>完了这些基础特征后,我发现有些特征重要性特别大(使用<code>Randomforest</code>得到),这时候我们又要请出我们第二大神器,交叉特征,比如月和假期的特征融合,这一波操作直接让我的特征到了6000+维度(如果将窗口扩大轻轻松松上万)</p>
<p>在这里要介绍一个特征生成的方法,有时候我们特征少,我们会采用自己命名的,自己生成,然后这个由于规律性比较大,<br>如果我们自己手动一个一个写的话,这上万<code>Fetures</code>够你写的,所以要让他自己生成特征,我们只要建好模子就行,由于这次<br>时间仓促,基本上我没有自己手动命名<code>feture</code>,全部都由程序生成,省掉很多代码量,具体可以看看代码实现,原理很简单.</p>
<h1 id="训练模型-train-model-ipynb"><a href="#训练模型-train-model-ipynb" class="headerlink" title="训练模型(train_model.ipynb)"></a>训练模型(<code>train_model.ipynb</code>)</h1><p>训练模型的话,一般比赛都推荐先使用树模型,一方面速度快,第二个可以看到<code>feture</code>的重要性,这对于你挑选交叉特征非常有用,模型调参的我这里就不讲,一方面我自己也不是很懂,第二个方面也网上教程也多,我讲的不一定比他好</p>
<p>这里要推荐一个发现有趣的包,<code>mlxtend</code>,我用他来进行<code>stacking</code>特别方便,有意思的时,我用他融合了四个模型,最后我的训练结果竟然为1,完全拟合了……</p>
<p>这个包可以很简单的进行模型的<code>stacking</code>,然而这个比赛我没有把他用好(手动滑稽)</p>
<p>通过训练模型后我们把模型存到<code>pkl</code>文件中,然后在用他来预测数据,这样在文件夹里转一圈的原因,因为原来打过部分比赛数据量太大,训练模型后内存不足,只能先<code>del</code>,清空内存,再预测,存到文件夹后,结束进程,清空内存,这样就能省下空间来读取下一步数据.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实在这个脚手架上可以扩展很多东西,比如最后搏一搏单车变摩托的时候,我就在分割数据和训练数据之间加了一个过滤清洗数据层,在训练模型和融合特征之间加了一个降维的中间层.</p>
<p>建立一个好的脚手架只是能让你在增添特征,选择特征时更加轻松,其实比赛看的还是你对数据的一种掌控力,建立这个脚手架主要是为了节省更多时间给提取特征、选择特征上.特征决定你的上限.</p>
<p>这次比赛比较特殊,模型在这个比赛效果可能没有规则好,因为数据量太小,我<code>stacking</code>一下直接完全拟合了.可惜验证的次数还是<br>太少,除去前面两次错误的提交,我只有三次验证机会,如果次数多一点的话,选择特征降维或者模型调参一下遏制拟合结果可能会好很多吧.</p>
<p>但是这次比赛自己学到了如何搭一个<code>ipy</code>的管道和增加了一些特征调参、特征降维的经验。因为以前看到的搭建管道资料都是基于<code>py</code>,很少基于<code>ipy</code>的,所以把自己搭建<code>ipy</code>管道经验分享出来,也希望自己写的这篇博文能够抛砖引玉,帮助大家搭建自己的完美管道.</p>
<p>附上我的<a href="https://github.com/mrzhangboss/electricAI" target="_blank" rel="external">开源示例</a>:  <a href="https://github.com/mrzhangboss/electricAI" target="_blank" rel="external">https://github.com/mrzhangboss/electricAI</a><br>大家觉得有帮助就给我点个star吧</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/DM/">DM</a><a href="/tags/competions/">competions</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/06/13/大航杯“智造扬中”电力AI大赛参赛经验/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/06/13/大航杯“智造扬中”电力AI大赛参赛经验/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/06/杂记/" title="杂记" itemprop="url">杂记</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="张伦" target="_blank" itemprop="author">张伦</a>
		
  <p class="article-time">
    <time datetime="2017-06-06T14:33:44.000Z" itemprop="datePublished"> 发表于 2017-06-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>pass</p>
</blockquote>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/summary/">summary</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/06/06/杂记/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/06/06/杂记/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/16/如何成为一名数据挖掘机/" title="如何成为一名数据挖掘机" itemprop="url">如何成为一名数据挖掘机</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="张伦" target="_blank" itemprop="author">张伦</a>
		
  <p class="article-time">
    <time datetime="2017-05-16T11:47:12.000Z" itemprop="datePublished"> 发表于 2017-05-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>自我介绍</p>
<p>前端 - &gt; 后端  -&gt; 数据挖掘机</p>
<p>ML DM AI  的区别</p>
<p>我的自学之旅</p>
<p>给新手的推荐</p>
<ul>
<li>机器学习课程(MOOC)</li>
<li>Kaggle、天池、数据城堡</li>
</ul>
<p>掌握的技能</p>
<ul>
<li>Java + Python</li>
<li>数据可视化</li>
<li>训练团队感</li>
</ul>
<p>未来的发展方向</p>
<ul>
<li>全栈数据挖掘工程师</li>
<li>增长黑客</li>
<li>ML算法工程师</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/05/16/如何成为一名数据挖掘机/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/05/16/如何成为一名数据挖掘机/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/04/爬虫分布式总结/" title="爬虫分布式总结" itemprop="url">爬虫分布式总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="张伦" target="_blank" itemprop="author">张伦</a>
		
  <p class="article-time">
    <time datetime="2017-04-04T08:03:55.000Z" itemprop="datePublished"> 发表于 2017-04-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>由于最近在一家数据服务公司实习，项目需要了解分布式，所以在这里基于<code>scrapy</code>的分布式总结一下爬虫的分布式实习</p>
</blockquote>
<h1 id="分布式起因"><a href="#分布式起因" class="headerlink" title="分布式起因"></a>分布式起因</h1><blockquote>
<p>单机无法完成全部工作任务所以要使用集群加速完成工作任务</p>
</blockquote>
<p>分布式有点像蚁群，一只蚂蚁举不起一只卡壳虫，但是几百只就能轻松的把他运回家</p>
<p>但是分布式设计必须科学，否则就像下面一样，一个和尚挑水，其他和尚围观</p>
<p><img src="/images/timg.jpg" alt="分工不合理，来源网络"></p>
<h1 id="分布式设计"><a href="#分布式设计" class="headerlink" title="分布式设计"></a>分布式设计</h1><p>分布式设计原理在于<strong>分工</strong></p>
<p>首先我们来看看爬虫怎么进行分工，单个爬虫运行根据<code>url</code>获取响应报文，然后通过解析报文返回结果或者下一次爬取目标，如果单个爬虫我们只要在内存维持一个<code>set</code>变量记住爬取过的<code>url</code>，这就是<code>scrapy</code>默认的方法。</p>
<p>但是我们无数个爬虫由于不在同一个进程，无法共享变量，所以我们只要让一个“<code>variable</code>（变量）”能够被被所以爬虫共享到就完成了主要功能</p>
<p>现在我们来完善具体细节<br>要求：</p>
<ul>
<li>爬虫能够轻松读取所以已爬取变量</li>
<li>爬虫能够加入已读取变量</li>
<li>爬虫能够获取下一次请求具体参数</li>
</ul>
<p>原则上我们可以使用内存映射来构建这个变量，但是读取，修改都不便利，所以可以先使用<code>redis</code>作为存贮变量的地方，使用<code>redis</code>提供的<code>set</code>我们替代<code>scrapy</code>框架的<code>set</code>变量。</p>
<p>现在我们已经决定我们要使用什么容器来存贮变量，接下来我们要考虑存什么变量。</p>
<p>我们先看<code>scrapy-redis</code>存贮了什么，分析源代码可知，<code>scrapy-redis</code>将返回的<code>Request</code>pickle话存入数据库，并且计算这个<code>Request</code>的32位hash值存入<code>redis</code>的<code>set</code>中过滤列表。</p>
<p><code>scrapy-redis</code>通过修改<code>scrapy</code>的调度器（scheduler）让其当爬虫没有<code>Request</code>需要处理时在<code>redis</code>中提取<code>Request</code>，实现分布式。</p>
<p>我们来分析一下这种方法，爬虫在爬取的过程中从<code>master</code>端获取<code>Request</code>，并不断生成<code>Request</code>到<code>master</code>端，<code>master</code>只是一个<code>redis</code>数据库，负责对<code>url</code>去重，分发任务。</p>
<p>我们来比较一下直接存取<code>url</code>这种方法，这种方法好处在于，<code>slaver</code>能够从上一个<code>Request</code>中获取全部信息，假如上一个<code>Request</code>需要存取获取的表单提取地址，我们下一次爬虫发起<code>Request</code>就能从上一个<code>Request</code>中获取参数。</p>
<p>当然由于我们存贮的是<code>Request</code>，一个<code>Request</code> <code>pickle</code>化之后的字符串比较长，当我们的任务列表里面有很多<code>Request</code>的时候，<code>redis</code>占用的内存会非常巨大。</p>
<p>当然如果爬虫启动的够多，生成一个就能把任务被调度下去，那么这个任务列表就能稳定在一个可控的范围。</p>
<p> <strong>总结</strong></p>
<p>每个爬虫即负责爬取数据，又负责生成下一个任务，即无主次之分，我们可以一次性在<code>docker</code>中启动上百个实例，我们只是用<code>redis</code>充当一个存放<code>变量</code>的地方。</p>
<p>但是这种方法也有一个缺点，我们不能自由的添加初始<code>url</code>，要想添加新的爬取任务，必须新建一个爬虫更新初始<code>url</code>，我们如果是想搭建一个自由添加<code>url</code>的爬虫，这种实现方式不大优雅。</p>
<h1 id="分布式改良"><a href="#分布式改良" class="headerlink" title="分布式改良"></a>分布式改良</h1><p>我们要修改程序框架，达到随时可以添加要爬取新任务，然而不影响爬虫集群</p>
<p><img src="/images/distribute_crawl.png" alt="爬虫框架"></p>
<p>我们独立出来<code>master</code>，<code>master</code>负责生成<code>Request</code>去重以及任务调度，而<code>slaver</code>只负责从<code>master</code>获取任务爬取。</p>
<p>这种方法我们可以很轻松对<code>master</code>改良而不影响<code>slaver</code>，通过让<code>master</code>定时从<code>数据库</code>中获取新的任务生成到任务列表，我们可以轻松添加新的任务到<code>slaver</code>集群中去。</p>
<p>下一步我们就介绍如何修改<code>scrapy-redis</code>达到我们新框架需要</p>
<h1 id="重构scrapy-redis"><a href="#重构scrapy-redis" class="headerlink" title="重构scrapy-redis"></a>重构<code>scrapy-redis</code></h1><p>参考：<br><a href="http://blog.csdn.net/bone_ace/article/details/50989104" target="_blank" rel="external">基于Redis的三种分布式爬虫策略</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/python/">python</a><a href="/tags/crawl/">crawl</a><a href="/tags/scrapy/">scrapy</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/04/04/爬虫分布式总结/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/04/04/爬虫分布式总结/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/02/17/天池大赛-口碑预测参赛感想/" title="天池大赛-口碑预测参赛感想" itemprop="url">天池大赛-口碑预测参赛感想</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="张伦" target="_blank" itemprop="author">张伦</a>
		
  <p class="article-time">
    <time datetime="2017-02-17T13:15:19.000Z" itemprop="datePublished"> 发表于 2017-02-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>第一次听说这个比赛还是去年在知乎上，当时也不知道这个比赛具体是怎么回事，当时自己还是一个小白，忙着搞懂各种主流的机器学习模型算法。</p>
</blockquote>
<p>当时在我心中，模型算法是数据挖掘的最重要的组成部分，搞懂这些才能真正搞定数据挖掘。我当时对算法模型和数据的理解是：模型就是风车，数据就是流水。我要做的事就是撘一个强健的风车，让数据流过。</p>
<p>当我还没接触实际的工作前，我还没有没有从编程工转向挖掘工。我太注重编程本身了，而忘记我自己真正要挖掘的宝藏。</p>
<p>我以前在<code>Quora</code>上搜如何成为数据科学家，我发现很多有经验的数据科学家他们都把“对数据的敏感和兴趣”作为数据科学家最重要的特征，而“了解各种算法模型并能应用到数据上”才是第二重要的。我当时不是太理解，我觉得后者才是更重要的。</p>
<h2 id="参赛感想"><a href="#参赛感想" class="headerlink" title="参赛感想"></a>参赛感想</h2><p>这次参赛算是我学习数据挖掘第一次实际的挖掘，以前学习各种算法模型都是准备的很好的数据，只要套上算法模型就能跑的很好。所以我一开始就拼命的去找类似的大赛，看看获胜者他们用的模型是什么。</p>
<p>这几天我好像抱着一堆瓶子，拼命的想把巨大的石头（数据）塞进瓶口里，看起来工作量很大，流了很多汗，其实什么都没有干。今天在看一个类似的比赛选手答辩的时候的视频，突然明白自己好像走了一个死胡同。自己拼命的想这找一个合适的瓶子（模型），其实我更应该做的是把石头（数据）磨碎。</p>
<h4 id="模型本身不重要，他只是一个载体，更重要的是数据。"><a href="#模型本身不重要，他只是一个载体，更重要的是数据。" class="headerlink" title="模型本身不重要，他只是一个载体，更重要的是数据。"></a>模型本身不重要，他只是一个载体，更重要的是数据。</h4><p>第一次参加这样大型比赛，有点激动也有点惶恐，如何将所学的应用到实际，还有在实际中提高自己还有待自己“挖掘”。虽然这个比赛奖金“丰富”，但是我觉得在这个比赛中得到的体会乐趣比奖金更诱人。</p>
<hr>
<p>比赛还有一个月，在这里立个小目标，争取跑到到前五页，我也会尽量抽时间把自己感想写出来。<br>未完待续。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/competition/">competition</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/02/17/天池大赛-口碑预测参赛感想/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/02/17/天池大赛-口碑预测参赛感想/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/12/23/how-to-be-data-scientist/" title="怎么成为数据科学家（翻译）" itemprop="url">怎么成为数据科学家（翻译）</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="张伦" target="_blank" itemprop="author">张伦</a>
		
  <p class="article-time">
    <time datetime="2016-12-23T14:05:56.000Z" itemprop="datePublished"> 发表于 2016-12-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>这是我从<code>Quora</code>上看到的一篇非常简短但详细的数据科学家的‘技能点’<br>来自eBay的一个数据科学家的回答<br>翻译来自<a href="https://www.quora.com/How-do-I-become-Data-analyst-scientist-Do-I-need-to-have-good-programming-skills/answer/Paul-Jeon-3?srid=ue3s8" target="_blank" rel="external">Quora回答</a></p>
</blockquote>
<p>这是面试谷歌、英特尔、脸书等大的世界五百强公司的数据科学家相关岗位常见的技术要求，在我看来主要有七点</p>
<ul>
<li>基本的编程基础</li>
</ul>
<blockquote>
<p>你应该了解一门统计学相关的编程语言，比如说<code>R</code>或<code>Python</code>（同时要了解<code>Numpy</code>和<code>Pandas</code>库），还要一门数据库查询语言比如<code>SQL</code></p>
</blockquote>
<ul>
<li>统计学</li>
</ul>
<blockquote>
<p>你应该要能解释零假设、P值、最大似然估计和置信空间这些短语，统计学在非常巨大的数据库里压缩数据和从挑选最重要的特征非常重要，在你得出结论和设计实验过程中也帮助巨大</p>
</blockquote>
<ul>
<li>机器学习</li>
</ul>
<blockquote>
<p>你必须能够搞懂K-近邻、随机森林和集合方法等机器学习算法，这些算法基本上都在<code>R</code>或<code>Python</code>中得到实现，这些算法能告诉你雇主你能够将计算机科学运用在实际的管理中。</p>
</blockquote>
<ul>
<li>数据重组</li>
</ul>
<blockquote>
<p>你应该要能够“清理”数据。比如数据库中”California” （加利福利亚）和“CA”是一样的，数据库里面可能出现用负值代表人口。这个总的来说就是识别坏（或者不正确）的数据然后校正（或删除)他们。</p>
</blockquote>
<ul>
<li>数据可视化</li>
</ul>
<blockquote>
<p>数据科学家不能就只是自己搞懂就行，他们需要把他们发现告诉你的产品经理，这样就能确保数据能很好的应用到程序里面去。所以，熟悉数据可视化工具比如说<code>ggplot</code>非常重要（这样你就能展示你的数据而不是仅仅谈谈而已）</p>
</blockquote>
<ul>
<li>软件工程</li>
</ul>
<blockquote>
<p>你应该了解算法和数据结构，因为这些东西在你写高效率的机器学习算法时非常重要，知道如何使用分支和使用高效的数据结构：队列、数组、列表、堆栈、树等等。</p>
</blockquote>
<ul>
<li>产品管理</li>
</ul>
<blockquote>
<p>这个绝对是有争议的，但是那些了解产品的人将会知道什么指标是最重要的。这里有很多数据可以用来做A/B测试，但是产品导向的数据科学家将会把最好的指标用来做测试。你要知道这些的意思：可用性测试、线框、保留和转换率、流量分析、客户反馈、内部日志、A/B测试。</p>
</blockquote>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/transform/">transform</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/12/23/how-to-be-data-scientist/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/12/23/how-to-be-data-scientist/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/11/13/协程解决递归错误/" title="协程解决递归错误原理" itemprop="url">协程解决递归错误原理</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="张伦" target="_blank" itemprop="author">张伦</a>
		
  <p class="article-time">
    <time datetime="2016-11-13T05:22:17.493Z" itemprop="datePublished"> 发表于 2016-11-13</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote>
<p>递归是高度抽象化问题的一个好东西，我们能从很多算法书里面看到这个，<br>但是递归虽然对于人来说好理解，但是计算机执行起来会损失性能，一个差的递归可能会耗光计算机的资源</p>
</blockquote>
<p>接下来我们来看一个非常经典的算法问题<code>Fibonacci数</code></p>
<pre><code>f(n) = n (n &lt; 2)
f(n) = f(n-1) + f(n-2)   (n &gt;= 2)
</code></pre><p>  我们可以很轻松的用递归解决掉它</p>
<pre><code>def fibonacci(n):
  if n &lt; 2:
      return n
  else:
      return fibonacci(n-1) + fibonacci(n-2)
</code></pre><p> 当<code>n</code>比较小的时候很快就出结果了，但是当<code>n</code>大于100时候要很久才能出结果，如果<code>n</code>大于1000，直接报出超出迭代深度的错误（python默认迭代深度是1000）</p>
<p>现在我们来解决两个问题</p>
<ol>
<li>为什么<code>n</code>大于100时候就很久才能算出结果</li>
<li>为什么<code>n</code>大于1000就报迭代深度的错误</li>
</ol>
<p>首先我们要知道一个概念就是堆栈段，每个进程开始运行时都会初始化一个堆栈段，这在物理上就是一小块内存，初始化堆栈段的时候计算机要做一些看起来同程序毫无关系的事情，比如说将寄存器的值推入堆栈里面等等</p>
<p>当你在运行主程序的时候你调用一个子函数，系统又会在当前堆栈段新建一个堆栈段，你子程序运行完了后会删掉这个堆栈段回到主程序，但是递归有个问题，就是他调用子程序的时候不会立即返回又会再调用自己</p>
<p>没办法因为子程序还没返回，所以计算机又初始化一个堆栈段，一个<code>n</code>为10的<code>fibonacci</code>函数就会初始化掉 <code>2 ** 10 = 1024</code>个堆栈段，<code>n</code>越大值会指数型增长，虽然1000个初始化在当今计算机上发不了多少时间，但是当我们<code>n</code>大于20就要 百万次初始化了</p>
<p>这就是为什么<code>n</code>很大的时候要很久才能算出结果，在一些单片机上面，循环调用空函数就是延时的功能，原理也就是堆栈初始化耗时间，而且不但耗时间假如像递归这样调用上百万次初始化而不返回将会耗掉大量内存在堆栈段上。</p>
<h2 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h2><blockquote>
<p>要解决这两个问题，一种方法是改算法，使用非递归算法，这个网上有很多，感兴趣的可以去搜一下，第二种是使用协程解决递归问题</p>
</blockquote>
<p>如何使用协程来解决递归呢我们先改主程序，将<code>return</code>换成<code>yield</code></p>
<pre><code>def _fibonacci(n):
  if n &lt; 2:
      yield n
  else:
      yield ( (yield (_fibonacci(n-1)) + (yield (_fibonacci(n-2)))
</code></pre><p>接下啦我们运行一下函数</p>
<pre><code>&gt;&gt;&gt; _fibonacci(10)
 &lt;generator object _fibonacci at 0x00000013A74779E8&gt;
</code></pre><p>没有返回结果,返回一个生成器，那我们用<code>list</code>简单的试一下吧</p>
<pre><code>&gt;&gt;&gt; list(_)
......
......
TypeError: unsupported operand type(s) for +: &apos;NoneType&apos; and &apos;NoneType&apos;
</code></pre><h4 id="生成器小知识"><a href="#生成器小知识" class="headerlink" title="生成器小知识"></a>生成器小知识</h4><blockquote>
<p>这里补充几点生成器的知识，懂得可以跳过</p>
</blockquote>
<p>生成器大家都用过，无论是<code>Python2</code>或<code>Python3</code>都不陌生,最简单的生成器是这种</p>
<pre><code>&gt;&gt;&gt; items = ( x for x in range(10))
</code></pre><p>我们一般搭配<code>for</code>来使用</p>
<pre><code>&gt;&gt;&gt; for i in items:
...         print(i)
...
</code></pre><p>我们也可以用协程来实现这个生成器</p>
<pre><code>def iter_func(n):
    for i in range(n):
        yield n
</code></pre><p>像上面一样使用<code>for</code>就能实现一样的功能，在这个例子里面<code>yield</code>好像变成了一个<code>return</code>的作用，在<code>for</code>语句中，随着每次请求都会<code>return</code>一个数过来</p>
<p>在这个里面<code>yield</code>好像就是这么个功能，但是<code>yield</code>的作用远远不止于此</p>
<p>我们现在来改一下这个函数</p>
<pre><code>def iter_func(n):
    for i in range(n):
        r = yield i
        print(&apos;result&apos;, r)
</code></pre><p>我们用<code>list</code>来运行一下这个函数</p>
<pre><code>&gt;&gt;&gt; list(iter_fun(2))
0
result None
1
result None
</code></pre><p><code>r</code>返回了一个<code>None</code>，我们尝试自己实现一下<code>for</code>循环,有两种方式</p>
<ul>
<li>next(generator)</li>
<li>generator.send(msg)</li>
</ul>
<p>先尝试用<code>next</code></p>
<pre><code>&gt;&gt;&gt; it = iter_fun(2)
&gt;&gt;&gt; next(it)
0
&gt;&gt;&gt; next(it)
result None
1
</code></pre><p>我们介绍一下<code>next</code>函数, <code>next</code>接受两个参数，第一个是生成器，第二个是返回的默认值,<code>next</code>函数在这里相当于下面这个函数</p>
<pre><code>def next(iterator, default=None):
    try:
        iterator.send(None)
    except StopIteration:
        if default:
            return default
        else:
            raise StopIteration()
</code></pre><p><strong>为什么第二个执行了<code>print</code>函数而第一个没有执行?</strong></p>
<h4 id="生成器工作原理"><a href="#生成器工作原理" class="headerlink" title="生成器工作原理"></a>生成器工作原理</h4><blockquote>
<p>这里我们介绍一下生成器的工作原理</p>
</blockquote>
<p>当我们使用调用一个函数的时候，一般是碰到<code>return</code>或者执行全部函数就会返回父函数</p>
<p>但是<strong>生成器</strong>不同，假如他执行函数碰到<code>yield</code>，他就会直接返回一个生成器。</p>
<p>这个生成器我们可以把它看做是邮递员，我们必须写好目的地,他才会帮我们把信寄出去。</p>
<p>现在我们分析一下生成器的具体流程，我们先定义一个简单的生成器</p>
<pre><code>def mygenerator(n):
    while True:
        r = yield n
        n -= 1
        print(&apos;result&apos;, r)
</code></pre><p> 然后我们调用这个生成器</p>
<pre><code>&gt;&gt;&gt; i = mygenerator(10)
&gt;&gt;&gt; i
&lt;generator object mygenerator at 0x7f420a339d00&gt;
</code></pre><p>我们得到一个生成器，我们先尝试发送一个地址给“邮递员”</p>
<pre><code>&gt;&gt;&gt; i.send(0)
...
TypeError: can&apos;t send non-None value to a just-started generator
</code></pre><p>我们得到一个错误，必须传递一个<code>None</code>，我们先不管，先送一个<code>None</code>值过去</p>
<pre><code>&gt;&gt;&gt; i.send(None)
10
</code></pre><p>我们得到一个<code>10</code>，再送一个地址过去</p>
<pre><code>&gt;&gt;&gt; i.send(None)
result None
9
</code></pre><p>我们现在来分析一下代码，第一次调用的时候直接返回了，第二次调用我们从<code>r = yield n</code>那行开始执行，并且运行到第二个<code>r = yield n</code>那里停止了</p>
<p><strong>就可以解释上面为什么要第一次传递<code>None</code>过去，因为第一次调用它会直接返回<code>yield</code>后面的值给我们，第二次调用 我们可以根据第一次生成器递给我们的值，决定我们第二次想寄的“信”，因为第一次传递过去“信”并不能被处理，所以Python强制我们传递一个None值过去</strong></p>
<hr>
<blockquote>
<p>我们回到上面的函数</p>
</blockquote>
<pre><code>def _fibonacci(n):
    if n &lt; 2:
        yield n
    else:
        yield ( (yield (_fibonacci(n-1)) + (yield (_fibonacci(n-2)))
</code></pre><p>我们来分析一下流程，为了解决上面的问题我们先把函数简化，去掉递归</p>
<pre><code>def f(n):
    yield (yield n) + (yield n - 1)
</code></pre><p>我们先创建一个生成器<code>i</code></p>
<pre><code>&gt;&gt;&gt; i = f(5)
&gt;&gt;&gt; i
 &lt;generator object f at 0x7f4a421d8f10&gt;
</code></pre><p>我们先启动i</p>
<pre><code>&gt;&gt;&gt; i.send(None)
5
</code></pre><p>我们再把得到<code>5</code>传给<code>i</code></p>
<pre><code>&gt;&gt;&gt; i.send(5)
4
</code></pre><p>我们得到<code>yield n -1</code>返回的4，我们再把4传给<code>i</code>，得到最终结果</p>
<pre><code>&gt;&gt;&gt; i.send(5)
9
</code></pre><p>假如我们把后面两个<code>send</code>的值换成其他值我们会得到不同的结果，这里我们可以看到我们，要实现上面函数必须要依靠一个<code>栈</code>，保存我们返回的生成器，然后依次调用生成器返回结果，具体代码如下</p>
<pre><code>def fibonacci(n):
    stack = [ _fibonacci(n)]
    last_result = None
    while stack:
        last = stack[-1]
        try:
            if isinstance(last, types.GeneratorType):
                stack.append(last.send(last_result))
                last_result = None
            else:
                last_result = stack.pop()
         except StopIteration:
             stack.pop()
     return result
</code></pre><p>我们这里用<code>stack</code>作为我们的堆栈，用<code>last_result</code>保存上一个生成器返回的值</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们使用协程解决掉了递归错误，但是这个方法并不可以给我们算法加速，虽然n为1000以上不会报递归错误，但是等待的时间还是很长很长。。。</p>
<p>虽然协程在这个方法里面并没有起到多大作业，协程在算法方面还是没有太多帮助，协程在计算机<code>I/O</code>还有网络请求方面有更好的效率，但是这次尝试让我们对协程如何使用有了一个清晰的了解</p>
<p>有兴趣的可以去了解一下协程在异步网络请求的应用</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/python3/">python3</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/11/13/协程解决递归错误/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/11/13/协程解决递归错误/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/10/09/ansible管理nginx负载均衡/" title="ansible管理nginx负载均衡" itemprop="url">ansible管理nginx负载均衡</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="张伦" target="_blank" itemprop="author">张伦</a>
		
  <p class="article-time">
    <time datetime="2016-10-09T15:15:06.000Z" itemprop="datePublished"> 发表于 2016-10-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>因为手头自己有三个服务器，所以想折腾一下负载均衡。</p>
</blockquote>
<p>两个<code>CentOS</code>，一个<code>Ubuntu</code>,都是比较新的。</p>
<p>一开始准备用<code>haproxy</code>来做负载均衡服务器，因为<code>haproxy</code>相比与<code>nginx</code>对<code>cookie</code>和<code>session</code>支持比较好，但是由于两个原因还是放弃了。</p>
<ol>
<li>服务器被阿里云封掉</li>
</ol>
<blockquote>
<p>简单的在<code>haproxy</code>中设置后端服务器后，过一段时间就显示强制备案页面，由于我的域名没有备案。</p>
</blockquote>
<p>后来我翻看了<code>nginx</code>日志发现，<code>haproxy</code>默认在<code>request header</code>里面带了<code>X-Host</code>，被阿里云发现了，这里提供一个解决方法</p>
<pre><code># 删除掉你header里面的 Host
# 在backend里面添加一句
http-request del-header Host
</code></pre><p>然而<code>nginx</code>里面默认是没有添加<code>Host</code>这个的，要你在<code>localtion</code>中添加两句，如下面</p>
<pre><code>    server {
  listen 80;
  server_name example.com;
  location / {
    proxy_pass       http://main;
    proxy_set_header Host            www.example.com; # add Host
        proxy_set_header X-Forwarded-For $remote_addr; # add X-Forwarded
  }
}
</code></pre><ol>
<li>haproxy支持多开</li>
</ol>
<blockquote>
<p>我试了很多种选项，确定<code>pidfile</code>、改变<code>uid</code>、<code>gid</code>等等，<code>haproxy</code>似乎可以允许很多个相同进程绑定同一个端口，虽然可以通过<code>pid</code>来写一套类似<code>service</code>管理的脚本，但终归很麻烦</p>
</blockquote>
<p>我看网上有人写了这个脚本，但是<code>nginx</code>自带了，还是用<code>nginx</code>比较好，而且<code>ansible</code>与<code>service</code>的交互还不错。</p>
<h2 id="nginx负载均衡"><a href="#nginx负载均衡" class="headerlink" title="nginx负载均衡"></a>nginx负载均衡</h2><blockquote>
<p>nginx负载均衡是通过反向代理来实现的，也就是把一台服务器的压力分摊到多台上面</p>
</blockquote>
<p>要想实现这个必须要有后端服务器，假设我们有一台后端服务器<code>1.1.1.1</code>，在代理主机的<code>nginx</code>配置系统<code>location</code>里面只要添加一条<code>proxy_pass</code>就行了</p>
<pre><code>    server {
listen 80;
server_name example.com;
location / {
    proxy_pass http://1.1.1.1;
}
}
</code></pre><p>  上面只是简单的实现了一个反向代理的功能，当你有一个后端服务群的时候，你就要使用负载均衡模块了，负载均衡模块在<code>nginx</code>配置特别简单，添加一个<code>upstream</code>模块，把服务器ip或者域名放到里面</p>
<pre><code>  upstream webservers{
    server 1.1.1.1 weight=10;
    server my.domain.com  weight=10;

}
</code></pre><p>  然后修改<code>proxy_pass</code>后的为<code>http://webservers</code>就行了</p>
<p>  ps： <code>nginx</code>对于后端反向代理服务器有个<code>max_fails</code>和<code>fail_timeout</code>属性，你要是设定了一个<code>max_fails</code>次数，你代理服务器拿取失败了几次就会在<code>fail_timeout</code>值之后尝试，和<code>haproxy</code>的<code>retry</code>属性差不多，但是似乎<code>haproxy</code>的<code>retry</code>不好使，我故意使用两个错误<code>ip</code>和正确<code>ip</code>，结果<code>nginx</code>能一直正确返回正确<code>ip</code>响应，而<code>haproxy</code>有时候能，有时候不行。</p>
<h2 id="nginx错误日志"><a href="#nginx错误日志" class="headerlink" title="nginx错误日志"></a>nginx错误日志</h2><blockquote>
<p>在调试<code>nginx</code>碰到一些错误，记录一下如何系统的解决方法</p>
</blockquote>
<ul>
<li>调用<code>service nginx start</code>失败</li>
</ul>
<p>首先看给的错误信息，假如让你看<code>systemctl status nginx.service</code>或<code>journalctl -xn</code>，输入去看</p>
<ol>
<li>格式错误（format error）</li>
</ol>
<p>一般你写的<code>nginx</code>的配置文件有问题，这时候可以用<code>nginx -t</code>检查格式，修改正确后会显示<code>success</code></p>
<ol>
<li>无法绑定地址（bind error）</li>
</ol>
<p>一般是因为有别的应用程序占用端口造成的，这时候用<code>netstat -tulpn</code>检查端口，然后选择<code>kill</code>掉占用端口的程序或者换一个端口</p>
<h2 id="ansible-playbook-编写"><a href="#ansible-playbook-编写" class="headerlink" title="ansible playbook 编写"></a>ansible playbook 编写</h2><blockquote>
<p>具体代码可以参考<a href="https://github.com/mrzhangboss/nginx-load-balance-ansible-playbook" target="_blank" rel="external">nginx均衡负载ansible-playbook</a><br>首先你得写一个<code>hosts</code></p>
</blockquote>
<pre><code>[ali]
my ansible_ssh_host=1.1.1.1 ansible_ssh_user=root 
[tencent]
main ansible_ssh_host=1.1.1.2 ansible_ssh_user=root
[digital]
google ansible_ssh_host=1.1.1.3 ansible_ssh_user=root
</code></pre><p>前面<code>[  ]</code>包着的是组名，最前面的<code>my</code>和<code>main</code>和<code>google</code>是<code>别名</code>，后面就是ip和用户名了。</p>
<p>写完<code>hosts</code>后要写两个<code>nginx</code>配置文件一个代理服务器的配置文件和一个后端服务器配置文件，<code>playbook</code>很简单就是复制<code>nginx</code>配置文件和重启<code>nginx</code>。</p>
<pre><code>---
- hosts: tencent
  remote_user: root

    tasks:
  - name: copy nginx config file 
    template: src=~/test/lunge_proxy.conf  dest=/etc/nginx/conf.d/lungelog.conf
    notify: restart nginx

    handlers:
  - name: restart nginx
    service: name=nginx state=restarted enabled=yes
</code></pre><p>解释一下<code>notify</code>，在复制完成之后就启用一个<code>handler</code>完成<code>nginx</code>的重启，当然这里也可以使用<code>reload</code>，假如在生产环境的话。</p>
<p>客户端和代理的<code>playbook</code>差不多就不多介绍了。</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p><a href="https://www.zybuluo.com/phper/note/90310" target="_blank" rel="external">nginx的配置、虚拟主机、负载均衡和反向代理</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/ansible/">ansible</a><a href="/tags/nginx/">nginx</a><a href="/tags/负载均衡/">负载均衡</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/10/09/ansible管理nginx负载均衡/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/10/09/ansible管理nginx负载均衡/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/10/01/about-diving-force/" title="关于驱动力" itemprop="url">关于驱动力</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="张伦" target="_blank" itemprop="author">张伦</a>
		
  <p class="article-time">
    <time datetime="2016-10-01T00:59:11.000Z" itemprop="datePublished"> 发表于 2016-10-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="驱动力是什么"><a href="#驱动力是什么" class="headerlink" title="驱动力是什么"></a>驱动力是什么</h2><blockquote>
<p>驱动力就鞭子，小的时候我们被父母教育考的好就是棒棒糖,考的差就是鞭子，等我们走进社会,工资就是我们是驱动力。</p>
</blockquote>
<p>我们看到过那些年薪百万的程序员，也看到过一些碌碌无为的码农,每个人都想成为那群大牛，工作得心应手、万人敬仰，工资难以”望其项背”.</p>
<p>但是我们同大牛和码农(差点打成马蓉…..)有什么区别呢，有些人说是人家那些大牛早早就积累了十万个小时，我们同大牛只是差了十万个小时.</p>
<p>这从某一方面上来看是对的，从某一方面来说又是不对的，君不看那些在公司辛辛苦苦工作几十年的码农早就积累了几十万小时，但是他们依旧是码农，除了业务逻辑比新手强。</p>
<p>那是什么原因让几十万个小时造不了一个大神呢？</p>
<p>很简单，就是<strong>驱动力</strong>。</p>
<p>码农是以工资作为驱动力的，而大神是以兴趣为驱动力的，很多码农一开始都同大神一样被编程的乐趣而吸引，然而大神坚持下来了，而码农呢，慢慢的像小孩子玩厌了新玩具，在慢慢的走入社会被工资左右，在慢慢的就开始盼望早点下班……</p>
<h2 id="怎么改变"><a href="#怎么改变" class="headerlink" title="怎么改变"></a>怎么改变</h2><blockquote>
<p>环境对我们的影响是潜移默化的，我们处在这个环境里面可能不知不觉就慢慢改变我们自己了</p>
</blockquote>
<p>那我们如何改变自己</p>
<h3 id="工作环境"><a href="#工作环境" class="headerlink" title="工作环境"></a>工作环境</h3><p> 假如你是一个工作党，找一个好的开发团队对你的影响是巨大的，假如你的小组死气沉沉，最好换一个即使工资很低</p>
<p> 假如你是一个学生党，比如我，尽量参加学生社团，那种偏技术的部门，在同一个部门里面一起奋斗的感觉非常好。</p>
<h3 id="学习环境"><a href="#学习环境" class="headerlink" title="学习环境"></a>学习环境</h3><ul>
<li>在搜索引擎上面多走几步</li>
</ul>
<p>很多时候我们遇到问题，google一下解决了就完了，我们要多问几个自己几个问题，这个问题为什么产生，如何避免，下一次还会遇到吗，还有及时收集自己的问题多总结，你要知道圣斗士之所以那么牛是因为人家从不在跌倒的地方跌倒第二次，你要知道bug不是我们的试卷，bug是我们的成神的<code>补丁</code></p>
<ul>
<li>培养开源精神</li>
</ul>
<p>github没事都上去溜达溜达，看到好的项目可以跟进，看看人家的代码同你的有什么不同，开源不代表抄袭，任何创新都是从模仿开始，不要老想着搞个大新闻大项目，其实很多项目都是从小项目开始的</p>
<ul>
<li>多输出</li>
</ul>
<p>其实很多人不知道，写东西也是学习的一种方法，因为很多时候我们学的东西有时候学的模拟两可，写出来有助你理清脉络，而且帮助后来者少走弯路，何乐而不为呢。</p>
<p>有些人说我没什么想写的，你找一些外国博客翻译也是可以的，通过翻译学习，一方面锻炼自己，一方面让更多人了解国外文化。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>成神是很难的，但是只要你在路上，不要回头就不难了。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/感想/">感想</a><a href="/tags/总结/">总结</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/10/01/about-diving-force/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/10/01/about-diving-force/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/09/17/recommendations-Programming-Colletive-Intelligence-impression/" title="集体智慧编程之推荐系统(Programming Colletive Intelligence)" itemprop="url">集体智慧编程之推荐系统(Programming Colletive Intelligence)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="张伦" target="_blank" itemprop="author">张伦</a>
		
  <p class="article-time">
    <time datetime="2016-09-17T13:36:00.000Z" itemprop="datePublished"> 发表于 2016-09-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>看过好几把关于机器学习的书,但是很多书只是停留于算法原理阶段,或者更着重介绍算法原理, &lt;&lt;集体智慧编程&gt;&gt;这本书更多的是从实践来介绍书,比如你要撘一个推荐系统你怎么做,,还有怎么来做一个垃圾邮件过滤系统等….<br>接下来介绍一下我对于做一个推荐系统的理解.</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>推荐系统是一个什么东西呢<br>简单来说就是两个字—-<code>推荐</code></p>
</blockquote>
<p>推荐系统的出现是伴随评价系统出现而出现的,评价系统就是我们的打分制,比如对一部电影每个人都对他进行打分</p>
<table>
<thead>
<tr>
<th>用户</th>
<th>电影A评价</th>
<th>电影B评价</th>
<th>新电影C评价</th>
<th>新电影D评价</th>
</tr>
</thead>
<tbody>
<tr>
<td>张三</td>
<td>5.0</td>
<td>3.5</td>
<td>4.9</td>
<td>2.0</td>
</tr>
<tr>
<td>李四</td>
<td>2.5</td>
<td>5.0</td>
<td>2.0</td>
<td>3.0</td>
</tr>
<tr>
<td>王二</td>
<td>3.1</td>
<td>4.7</td>
<td></td>
</tr>
</tbody>
</table>
<p>比如现在三个人张三李四王二,王二有两部电影没有看过,但是张三和李四看过了,现在就是要把电影C或D推荐给王二,推荐系统就是从其他数据分析来确定推荐次序</p>
<h2 id="相似度"><a href="#相似度" class="headerlink" title="相似度"></a>相似度</h2><blockquote>
<p>推荐系统如何根据其他用户的数据来推荐呢</p>
</blockquote>
<p>这里就要介绍一个相似度的概念,也可以加权系数,对于张三和李四,这两个人都看过电影C和D,但是我们该听谁的呢,我们可以把两个人的评价加起来然后排序,但是假如张三和李四品味相差太多,而且张三的评价可能会把某个王二喜欢看的电影评价总值拉低</p>
<p>这个时候我们就要考虑一个相似度问题,就是尽量避免一些品味同王二不同的人对排名造成影响</p>
<p>这里我们引进相似度这个概念,我们看张三和李四对电影A、B同王二的差别，这里我们使用距离这个概念，我们使用距离公式 <code>l=（（r1^2 + r2^2+....rN^2)^1/n)</code></p>
<p>然后通过距离算得<code>S(相似度)=1/(1+l)</code></p>
<p><em>当l=0时,两者相似度为1(最大),当l很大时,相似度几乎为零</em></p>
<table>
<thead>
<tr>
<th>用户</th>
<th>电影A评价</th>
<th>电影B评价</th>
<th>相似度</th>
</tr>
</thead>
<tbody>
<tr>
<td>张三</td>
<td>5.0</td>
<td>3.5</td>
<td>0.23</td>
</tr>
<tr>
<td>李四</td>
<td>2.5</td>
<td>5.0</td>
<td>0.59</td>
</tr>
</tbody>
</table>
<p>通过求相似度(权重)我们就把同我们臭味相投的人的评价提高了,那些同我们不一样品味的人评价作用降低了</p>
<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>基于人物的评价推荐有个缺点就是人的评价有时候会比物品多,而且变化频繁,假如使用上面的方法的话,每次每一个用户评价过后,就要重新算一次相似度了,假如用户不多或者电影不多还好,一旦数据偏多服务器就扛不住了</p>
<p>所以我们要换一个角度出发,计算物品的相似度,这样图表就变成这样了</p>
<table>
<thead>
<tr>
<th>电影</th>
<th>用户-张三</th>
<th>用户-李四</th>
<th>相似度</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>5.0</td>
<td>2.5</td>
<td></td>
</tr>
<tr>
<td>B</td>
<td>3.5</td>
<td>5.0</td>
<td></td>
</tr>
</tbody>
</table>
<p>这样有个好处就是可以离线处理数据,我们可以搭建一个离线处理系统,让一个系统专门处理数据,当服务器需要的时候再拿取过去.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>搭建一个简单推荐系统并不会你想象中那么简单,但是要搭建一个功能强大速度快的推荐系统需要的不仅仅是这么一点,还需要考虑系统的稳定和速度.</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/reading/">reading</a><a href="/tags/books/">books</a><a href="/tags/impression/">impression</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/09/17/recommendations-Programming-Colletive-Intelligence-impression/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/09/17/recommendations-Programming-Colletive-Intelligence-impression/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/"><span></span>Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/python/" title="python">python<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/summary/" title="summary">summary<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/development/" title="development">development<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/总结/" title="总结">总结<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/hookman/" title="hookman">hookman<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/notebook/" title="notebook">notebook<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/competition/" title="competition">competition<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/mock/" title="mock">mock<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/patch/" title="patch">patch<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/测试/" title="测试">测试<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/感想/" title="感想">感想<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/HTTP/" title="HTTP">HTTP<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/ansible/" title="ansible">ansible<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/nginx/" title="nginx">nginx<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/负载均衡/" title="负载均衡">负载均衡<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/git/" title="git">git<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/工作/" title="工作">工作<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/工具心得/" title="工具心得">工具心得<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/database/" title="database">database<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/github/" title="github">github<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://segmentfault.com/ " target="_blank" title="一个面向程序员交流分享的新一代社区">segmentfault</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=5364356330&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m lunge. <br/>
			This is my blog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/5364356330" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/mrzhangboss" target="_blank" class="icon-github" title="github"></a>
		
		
		<a href="http://stackoverflow.com/users/6599843" target="_blank" class="icon-stack-overflow" title="stackoverflow"></a>
		
		
		<a href="https://twitter.com/mrzhangboss" target="_blank" class="icon-twitter" title="twitter"></a>
		
		
		<a href="https://www.facebook.com/100011375031071" target="_blank" class="icon-facebook" title="facebook"></a>
		
		
		
		
		<a href="http://www.zhihu.com/people/zhang-lun-59-53" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
		<a href="mailto:2529450174@qq.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="张伦">张伦</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-80810286-1,UA-80810286-2', 'auto,auto');  
ga('send', 'pageview');
</script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
